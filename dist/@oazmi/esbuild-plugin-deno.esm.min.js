function qt(e,t,r){let o=r===void 0?t:t.bind(r),n=e.length-1;for(;n>=0;){if(o(e[n],n,e))return n;n--}return-1}function Xt(e,t,r){let o=e.findLastIndex(t,r);return o===-1?void 0:e[o]}Array.prototype.findLastIndex||(Array.prototype.findLastIndex=function(e,t){return qt(this,e,t)});Array.prototype.findLast||(Array.prototype.findLast=function(e,t){return Xt(this,e,t)});Uint8Array.prototype.findLastIndex||(Uint8Array.prototype.findLastIndex=function(e,t){return qt(this,e,t)});Uint8Array.prototype.findLast||(Uint8Array.prototype.findLast=function(e,t){return Xt(this,e,t)});var $r={},Jt=Wr(globalThis,$r);function Wr(e,t){return new Proxy(e,{get(r,o,n){return o in t?t[o]:e[o]},set(r,o,n){return o in t&&delete t[o],e[o]=n,!0},deleteProperty(r,o){let n=!1;return o in t&&(delete t[o],n=!0),o in e&&(delete e[o],n=!0),n},ownKeys(r){let o=Reflect.ownKeys(e),n=Reflect.ownKeys(t),s=new Set(n);return[...o.filter(i=>!s.has(i)),...n]},defineProperty(r,o,n){return o in t&&delete t[o],Reflect.defineProperty(e,o,n),!0},getOwnPropertyDescriptor(r,o){return o in t?Reflect.getOwnPropertyDescriptor(t,o):Reflect.getOwnPropertyDescriptor(e,o)},has(r,o){return o in t||o in e}})}var Br=Array;var Qt=JSON;var Zt=Number,Ne=Object,ze=Promise;var er=Symbol;var ne=e=>e.length===0;var De=Br.isArray;var at=Qt.parse,be=Qt.stringify;var Oe=Zt.isFinite;var se=Zt.parseInt,ct=Ne.assign;var W=Ne.entries;var pt=Ne.fromEntries;var tr=Ne.getPrototypeOf;var lt=Ne.keys;var q=()=>{let e,t;return[new Promise((o,n)=>{e=o,t=n}),e,t]},ut=ze.all.bind(ze);var Be=ze.resolve.bind(ze);var dt=er.iterator;var rr=er.toStringTag;var ve=encodeURI;var Pe=decodeURI;var T;(function(e){e[e.LOG=0]="LOG",e[e.ASSERT=0]="ASSERT",e[e.ERROR=1]="ERROR",e[e.PRODUCTION=1]="PRODUCTION",e[e.MINIFY=1]="MINIFY"})(T||(T={}));var X=(e,t,...r)=>o=>e[t].bind(o,...r);var Ge=(e,t,...r)=>e[t].bind(e,...r),mt=e=>e.prototype,or=mt(Array),pe=mt(Map),ft=mt(Set);var gt=X(or,"pop"),le=X(or,"push");var _t=X(ft,"add");var ht=X(ft,"delete");var xt=X(ft,"has");var yt=X(pe,"delete"),bt=X(pe,"entries"),vt=X(pe,"forEach"),ue=X(pe,"get"),Re=X(pe,"has"),Pt=X(pe,"keys"),Ee=X(pe,"set"),Rt=X(pe,"values");var Ae=e=>tr(e).constructor;var He=e=>{let t=typeof e;return t==="object"||t==="function"};var ie=e=>typeof e=="object",Ke=De;var x=e=>typeof e=="string";var Yr=/[.*+?^${}()|[\]\\]/g,we=e=>e.replaceAll(Yr,"\\$&"),te=(e,t,r="")=>e.startsWith(t)?r+e.slice(t.length):void 0,Ve=(e,t,r="")=>e.endsWith(t)?(t===""?e:e.slice(0,-t.length))+r:void 0,qr=`\r
`,O;(function(e){e[e.NONE=0]="NONE",e[e.STRING=1]="STRING",e[e.INLINE_COMMENT=2]="INLINE_COMMENT",e[e.MULTILINE_COMMENT=3]="MULTILINE_COMMENT"})(O||(O={}));var Et=e=>{e=" "+e.replaceAll(qr,`
`)+" ";let t=e.length-1,r=[],o=le(r),n=gt(r),s=O.NONE;for(let i=1;i<t;i++){let a=e[i];switch(a){case"/":{if(s===O.NONE){let c=e[i+1];if(s=c==="/"?O.INLINE_COMMENT:c==="*"?O.MULTILINE_COMMENT:O.NONE,s!==O.NONE){i++;continue}}break}case"*":{if(s===O.MULTILINE_COMMENT&&(s=e[i+1]==="/"?O.NONE:s,s===O.NONE)){i++;continue}break}case`
`:s=s===O.INLINE_COMMENT?O.NONE:s;case"	":case"\v":case" ":{if(s===O.NONE)continue;break}case'"':{s=s===O.NONE?O.STRING:s===O.STRING?O.NONE:s;break}case"}":case"]":{if(s===O.NONE){let c=n();c!==","&&o(c)}break}}(s===O.NONE||s===O.STRING)&&o(a==="\\"?a+e[++i]:a)}return r.join("")};var Xr=W({"node:":"node","npm:":"npm","jsr:":"jsr","blob:":"blob","data:":"data","http://":"http","https://":"https","file://":"file","./":"relative","../":"relative"}),Jr=["blob","data","relative"],Qr=["jsr","npm","node"],Zr=["jsr:","npm:","node:"],Q="/",Ye="./",wt="../",eo=/\\/g,to=/^[a-z]\:[\/\\]/i,ro=/^[\/\\]([a-z])\:[\/\\]/i,oo=/^\/+/;var no=/\/?[^\/]+$/,so=/^(?<basename>.+?)(?<ext>\.[^\.]+)?$/,io=/^(?<protocol>jsr:|npm:|node:)(\/*(@(?<scope>[^\/\s]+)\/)?(?<pkg>[^@\/\s]+)(@(?<version>[^\/\r\n\t\f\v]+))?)?(?<pathname>\/.*)?$/,ae=(e,t)=>e.startsWith(t),cr=(e,t)=>e.endsWith(t),kt=e=>ae(e,Q)||ae(e,"~")||to.test(e),K=e=>{if(!(!e||e==="")){for(let[t,r]of Xr)if(ae(e,t))return r;return kt(e)?"local":"relative"}},B=e=>{e=Pe(x(e)?e:e.href);let{protocol:t,scope:r,pkg:o,version:n,pathname:s}=io.exec(e)?.groups??{};if(t===void 0||o===void 0)throw new Error(T.ERROR?"invalid package url format was provided: "+e:"");let i=r||void 0,a=n||void 0,c=s||Q,p=`${i?"@"+i+Q:""}${o}${a?"@"+a:""}`,u=ve(`${t}/${p}${c}`);return{protocol:t,scope:i,pkg:o,version:a,pathname:c,host:p,href:u}},F=(e,t)=>{if(!x(e))return e;e=C(e);let r=t;if(x(t)&&t!==""){let u=K(t);if(Jr.includes(u))throw new Error(T.ERROR?"the following base scheme (url-protocol) is not supported: "+u:"");r=F(t)}let o=K(e),n=r?r.protocol:void 0,s=Qr.includes(o),i=Zr.includes(n),a=ae(e,"/"),c=o==="local",p=o==="relative";if(s)return new URL(B(e).href);if(r&&i&&(a||p)){let{host:u,protocol:l,pathname:f}=B(r);if(a)return new URL(`${l}/${ve(u)}${ve(e)}`);if(p){let d=new URL(e,"x:"+f).pathname;return new URL(`${l}/${ve(u)}${d}`)}}return r&&(a||p)?new URL(e,r):c?new URL("file://"+ve(e)):new URL(e)},ao=e=>e.replace(oo,"");var de=e=>ae(e,Ye)?e:ae(e,Q)?"."+e:Ye+e,A=e=>cr(e,Q)?e:e+Q;var pr=(e,t={})=>{let{keepRelative:r=!0}=ie(t)?t:{},o=e.split(Q),n=o.at(-1),s=[".."],i=r&&o[0]===".";o.length>=2&&(n==="."||n==="..")&&o.push("");for(let c of o)c===".."?s.at(-1)!==".."?s.pop():s.push(c):c!=="."&&s.push(c);return s.shift(),i&&s[0]!==".."&&s.unshift("."),s.join(Q)},me=(e,t)=>pr(C(e),t),C=e=>e.replaceAll(eo,Q);var ar=e=>ao(no.exec(e)?.[0]??""),co=e=>{let{basename:t="",ext:r=""}=so.exec(e)?.groups??{};return[t,r]},fe=e=>{let t=me(e),r=ar(t),o=r.length,n=o>0?t.slice(0,-o):t,s=ar(n.slice(0,-1)),[i,a]=co(r);return{path:t,dirpath:n,dirname:s,filename:r,basename:i,extname:a}},Le=e=>{if(x(e)){if(K(e)!=="file")return;e=new URL(e)}return ae(e.protocol,"file:")?C(Pe(e.pathname)).replace(ro,"$1:/"):void 0},re=e=>{let t=x(e);return Le(e)??(t?C(e):e.href)};var lr=(...e)=>{e=e.map(r=>r==="."?Ye:r===".."?wt:r);let t=e.reduce((r,o)=>{let n=r.pop(),s=cr(n,Q),i=s?n:n+Q;if(!s){let a=ae(o,Ye),c=ae(o,wt);a?o="."+o:c&&(o=wt+o)}return r.push(i,o),r},[Q]);return t.shift(),pr(t.join(""))},oe=(...e)=>lr(...e.map(C)),po=(e,t=kt)=>{let r=x(e)?()=>e:e;return(...o)=>{let n=o.findLastIndex(t);return n>=0?o=o.slice(n):o.unshift(A(r())),lr(...o)}},St=(e,t=kt)=>{x(e)&&(e=C(e));let r=x(e)?()=>e:()=>C(e()),o=po(r,t);return(...n)=>o(...n.map(C))};var _;(function(e){e[e.DENO=0]="DENO",e[e.BUN=1]="BUN",e[e.NODE=2]="NODE",e[e.CHROMIUM=3]="CHROMIUM",e[e.EXTENSION=4]="EXTENSION",e[e.WEB=5]="WEB",e[e.WORKER=6]="WORKER"})(_||(_={}));var U=Jt,lo={[_.DENO]:()=>!!U.Deno?.version,[_.BUN]:()=>!!U.Bun?.version,[_.NODE]:()=>!!U.process?.versions,[_.CHROMIUM]:()=>!!U.chrome?.runtime,[_.EXTENSION]:()=>!!U.browser?.runtime,[_.WEB]:()=>!!U.window?.document,[_.WORKER]:()=>!!(ie(U.self)&&He(U.WorkerGlobalScope)&&U.self instanceof U.WorkerGlobalScope)},uo=[_.DENO,_.BUN,_.NODE,_.CHROMIUM,_.EXTENSION,_.WEB,_.WORKER],Me=()=>{for(let e of uo)if(lo[e]())return e;throw new Error(T.ERROR?`failed to detect current javascript runtime!
please report this issue to "https://github.com/omar-azmi/kitchensink_ts/issues", along with information on your runtime environment.`:"")},ur=e=>{switch(e){case _.DENO:return U.Deno;case _.BUN:return U.Bun;case _.NODE:return U.process;case _.CHROMIUM:return U.chrome;case _.EXTENSION:return U.browser;case _.WEB:return U.window;case _.WORKER:return U.self;default:throw new Error(T.ERROR?`an invalid runtime enum was provided: "${e}".`:"")}},dr=(e,t=!0)=>{let r=ur(e);if(!r)throw new Error(T.ERROR?`the requested runtime associated with the enum "${e}" is undefined (i.e. you're running on a different runtime from the provided enum).`:"");switch(e){case _.DENO:case _.BUN:case _.NODE:return C(r.cwd());case _.CHROMIUM:case _.EXTENSION:return r.runtime.getURL("");case _.WEB:case _.WORKER:return new URL("./",t?r.location.href:r.location.origin).href}};var mo={args:[]},Ct=async(e,t,r={})=>{let{args:o,cwd:n,signal:s}={...mo,...r},i=ne(o);if(!ur(e))throw new Error(T.ERROR?`the requested runtime associated with the enum "${e}" is undefined (i.e. you're running on a different runtime from the provided enum).`:"");if(!t&&i)return{stdout:"",stderr:""};switch(e){case _.DENO:case _.BUN:case _.NODE:{let{exec:c}=await _o(),p=i?t:`${t} ${o.join(" ")}`,[u,l,f]=q();return c(p,{cwd:n?re(n):void 0,signal:s},(d,g,w)=>{d&&f(d.message),l({stdout:g,stderr:w})}),u}default:throw new Error(T.ERROR?`your non-system runtime environment enum ("${e}") does not support shell commands`:"")}};var fo;var go=async()=>import("node:child_process"),_o=async()=>fo??=await go();var ho=["size","mtime","atime","birthtime","ctime","dev","mode"],Ds=["isFile","isDirectory","isSymlink",...ho];var It=e=>{let t=[];e.forEach(n=>{t.push(...n)});let r=new Map([...new Set(t)].map(n=>[n,new Set])),o=ue(r);for(let[n,s]of e)s.forEach(i=>o(i).add(n));return r},ke=class{constructor(t,r){let o=t??(r?It(r):new Map),n=r??(t?It(t):new Map),s=Ee(o),i=Ee(n),a=yt(o),c=yt(n),p=o.size,u=n.size,l=vt(o),f=vt(n),d=ue(o),g=ue(n),w=Re(o),G=Re(n),Y=bt(o),M=bt(n),$=Pt(o),D=Pt(n),L=Rt(o),z=Rt(n),k=(m,...v)=>{let E=d(m)??(s(m,new Set)&&d(m)),j=xt(E),J=_t(E);for(let H of v)j(H)||(J(H),g(H)?.add(m)||i(H,new Set([m])))},S=(m,...v)=>{let E=g(m)??(i(m,new Set)&&g(m)),j=xt(E),J=_t(E);for(let H of v)j(H)||(J(H),d(H)?.add(m)||s(H,new Set([m])))},N=()=>{o.clear(),n.clear()},P=(m,v=!1)=>{let E=d(m);if(E){for(let j of E)g(j).delete(m);v?E.clear():v=a(m)}return v},h=(m,v=!1)=>{let E=g(m);if(E){for(let j of E)d(j).delete(m);v?E.clear():v=c(m)}return v};ct(this,{fmap:o,rmap:n,size:p,rsize:u,forEach:l,rforEach:f,get:d,rget:g,has:w,rhas:G,entries:Y,rentries:M,keys:$,rkeys:D,values:L,rvalues:z,add:k,radd:S,clear:N,delete:P,rdelete:h,remove:(m,...v)=>{let E=d(m);if(E){let j=ht(E);for(let J of v)j(J)&&g(J).delete(m)}},rremove:(m,...v)=>{let E=g(m);if(E){let j=ht(E);for(let J of v)j(J)&&d(J).delete(m)}},set:(m,v)=>(P(m,!0),k(m,...v),this),rset:(m,v)=>(h(m,!0),S(m,...v),this),[dt]:Y,[rr]:"InvertibleMap"})}};var qe=class{wmap=new WeakMap;smap=new Map;pick(t){return He(t)?this.wmap:this.smap}get(t){return this.pick(t).get(t)}set(t,r){return this.pick(t).set(t,r),this}has(t){return this.pick(t).has(t)}delete(t){return this.pick(t).delete(t)}},xo=Symbol(T.MINIFY||"represents an unset value for a tree");var ei=Symbol(T.MINIFY||"a rejection by a throttled function"),ti=Symbol(T.MINIFY||"a timeout by an awaited promiseTimeout function");var yo=(e,t=!1)=>{let r=t?new qe:new Map,o=Ge(r,"get"),n=Ge(r,"set"),s=Ge(r,"has");return{fn:a=>{let c=s(a),p=c?o(a):e(a);return c||n(a,p),p},memory:r}},Nt=e=>yo(e).fn;var Xe="x|0|[1-9]\\d*",bo=`(?<major>${Xe})\\.(?<minor>${Xe})\\.(?<patch>${Xe})`,vo="(?<prerelease>[^\\+\\s]*)",Po="(?<build>[^\\s]*)",mr=new RegExp(`${bo}(?:\\-${vo})?(?:\\+${Po})?`),Ro=/^\=*v*\s*/i,Eo=/^[xX\\*]$/,wo=/\-|\+/,ko=new RegExp(`^${Xe}$`),So="<=|>=|!=|<|>|=|\\^|\\~",Co=new RegExp(`^(?<operator>${So})?\\s*(?<semver>.*)$`),Dt=(e,t)=>e>t?1:e===t?0:-1,Io=e=>{let t=mr.exec(e);if(!t)return;let{major:r="0",minor:o="0",patch:n="0",prerelease:s="",build:i=""}=t.groups,a=se(r),c=se(o),p=se(n);return Oe(a)&&Oe(c)&&Oe(p)?{major:a,minor:c,patch:p,prerelease:s,build:i}:void 0},Je=e=>e.trim().replace(Ro,""),Qe=e=>Io(Je(e)),No=e=>{let{major:t="x",minor:r="x",patch:o="x",build:n="",prerelease:s=""}=e;return`${t}.${r}.${o}`+(s?"-"+s:"")+(n?"+"+n:"")},fr=(e,t)=>{e=x(e)?Qe(e):e,t=x(t)?Qe(t):t;let{major:r,minor:o,patch:n}=e,{major:s,minor:i,patch:a}=t;return r!==s?Dt(r,s):o!==i?Dt(o,i):Dt(n,a)},Do=e=>e.map(r=>x(r)?Qe(r):r).toSorted(fr),Oo=e=>{let t="x",r=e.search(wo),o=r>=0?e[r]:"-",[n="",s=""]=e.split(o,2),i=n.split(".").toReversed(),a=[],c=ne(i);for(let p=0;p<3;p++){let u=i.pop()||t,l=Eo.test(u)?t:u;c||=!ko.test(l),a.push(c?t:l)}return a.join(".")+(s?o+s:"")},Ao=e=>{let t=Co.exec(e),r="x";if(!t)throw new Error(`[semver]: invalid comparator: "${e}"`);let{operator:o="",semver:n=""}=t.groups,s=o||"=",i=mr.exec(Oo(Je(n)));if(!i)throw new Error(`[semver]: error parsing semver: "${n}"`);let{major:a=r,minor:c=r,patch:p=r,prerelease:u="",build:l=""}=i.groups,f=a===r?void 0:se(a),d=c===r?void 0:se(c),g=p===r?void 0:se(p);return{operator:s,major:f,minor:d,patch:g,prerelease:u,build:l}},Ot={tokenExp:"[OR]",parseExp:/\s*\|\|\s*/g,lexer(e){return e.split(this.tokenExp)}},Ze={tokenExp:"[HYPHEN]",parseExp:/\s+\-\s+/g,lexer(e){let t=e.match(Lo);if(!t)return;let r=Je(t[1]),o=Je(t[2]);return[r,o]}},Lo=new RegExp(`^(.+?)${we(Ze.tokenExp)}(.+?)$`),At={tokenExp:"[AND]",parseExp:/\s+/g,lexer(e){return e.split(this.tokenExp)}},Mo=["=","!=",">=","<=",">","<","~","^"],jo=[">","<","!="],To=e=>{for(let t of Mo)e=e.replaceAll(new RegExp(`${we(t)}\\s*`,"g"),t);return e},Se=e=>{if(x(e)){let a=Ze.lexer(e);if(a){let[c,p]=a;return[...Se(`>=${c}`),...Se(`<=${p}`)]}e=Ao(e)}let{operator:t="=",major:r,minor:o,patch:n,prerelease:s,build:i}=e;if(r===void 0)return jo.includes(t)?[{operator:"=",major:-1,minor:-1,patch:-1}]:[{operator:">=",major:0,minor:0,patch:0}];if(o===void 0)switch(t){case"!=":return[{operator:"<",major:r,minor:0,patch:0},{operator:">=",major:r+1,minor:0,patch:0}];case"<":return[{operator:"<",major:r,minor:0,patch:0}];case"<=":return[{operator:"<",major:r+1,minor:0,patch:0}];case">":return[{operator:">=",major:r+1,minor:0,patch:0}];case">=":return[{operator:">=",major:r,minor:0,patch:0}];default:return Se({operator:"^",major:r,minor:0,patch:0})}if(n===void 0)switch(t){case"!=":return[{operator:"<",major:r,minor:o,patch:0},{operator:">=",major:r,minor:o+1,patch:0}];case"<":return[{operator:"<",major:r,minor:o,patch:0}];case"<=":return[{operator:"<",major:r,minor:o+1,patch:0}];case">":return[{operator:">=",major:r,minor:o+1,patch:0}];case">=":return[{operator:">=",major:r,minor:o,patch:0}];case"^":if(r>0||o>0)return Se({operator:"^",major:r,minor:o,patch:0});default:return Se({operator:"~",major:r,minor:o,patch:0})}switch(t){case"^":{let a,c;return r>0?(a={operator:">=",major:r,minor:o,patch:n,prerelease:s,build:i},c={operator:"<",major:r+1,minor:0,patch:0}):o>0?(a={operator:">=",major:0,minor:o,patch:n,prerelease:s,build:i},c={operator:"<",major:0,minor:o+1,patch:0}):(a={operator:"=",major:0,minor:0,patch:n,prerelease:s,build:i},c=a),[a,c]}case"~":{let a={operator:">=",major:r,minor:o,patch:n,prerelease:s,build:i},c={operator:"<",major:r,minor:o+1,patch:0};return[a,c]}default:return[{operator:t,major:r,minor:o,patch:n,prerelease:s,build:i}]}},gr=e=>{let t=To(e).replaceAll(Ot.parseExp,Ot.tokenExp).replaceAll(Ze.parseExp,Ze.tokenExp).replaceAll(At.parseExp,At.tokenExp),r=[];for(let o of Ot.lexer(t)){let n=[];r.push(n);let s=At.lexer(o).map(Se).flat(1);n.push(...s)}return r},Fo=[["=","<=",">="],["!=",">",">="],["!=","<","<="]],Uo=(e,t)=>{e=x(e)?Qe(e):e,t=x(t)?gr(t):t;for(let r of t){let o=!0;for(let n of r){let s=n.operator,i=fr(e,n);if(Fo.at(i).includes(s)===!1||n.major<0){o=!1;break}}if(o)return!0}return!1},Lt=(e,t)=>{t=x(t)?gr(t):t;let r=Do(e).toReversed();for(let o of r)if(Uo(o,t))return No(o)};var ce=e=>(K(e)??"relative")!=="relative",je=e=>e.startsWith("./")||e.startsWith("../"),Mt=(e,t=ce)=>{let r=St(e,t);return(o,n)=>{if(!o)return r();if(o.startsWith("/")&&n)return re(F(o,n));if(ce(o))return C(o);let s=de(o);return n?r(n,s):r(s)}},ge={redirect:"follow",cache:"force-cache"},_e=A(C(dr(Me(),!0))),he=Mt(_e,ce),xe=()=>{};var $o=async(e,t)=>{for(let r of e){let o=await fetch(r,{...ge,...t}).catch(xe);if(o?.ok)return o;await o?.body?.cancel()}},Te=async(e,t)=>{let r=await $o(e,t);if(r){let o=r.url;return r.body?.cancel(),o}};var _r=(e,t)=>{e=me(e);let r=t[e];if(r)return r;let o=lt(t).filter(n=>n.endsWith("/")).toSorted((n,s)=>s.length-n.length);for(let n of o)if(e.startsWith(n)){let s=t[n];if(!s.endsWith("/"))throw new Error(`the value ("${s}") of the matched import-map key ("${n}") for the path alias "${e}" MUST end with a trailing slash ("/") to be specification compliant.`);return e.replace(n,s)}},et=([e,t],[r,o])=>r.length-e.length,Wo={baseAliasDir:"",basePathDir:"",sort:!0,errorCheck:!0},tt=(e,t,r)=>{let{baseAliasDir:o,basePathDir:n,errorCheck:s,sort:i}={...Wo,...r};o=Ve(o,"/")??o,n=Ve(n,"/")??n;let a=te(me(e),o),c=a===""||o!==""&&a?.startsWith("/")?"."+a:a;if(c===void 0)return tt(e,t,{baseAliasDir:"",basePathDir:n,errorCheck:s,sort:i});i&&(t=t.toSorted(et));for(let[p,u]of t){let l=te(c,p);if(l!==void 0){if(s&&p.endsWith("/")&&!u.endsWith("/"))throw new Error(`the value ("${u}") of the matched import-map key ("${p}") for the path alias "${e}" MUST end with a trailing slash ("/") to be specification compliant.`);let f=n===""||ce(u)?u:oe(A(n),u);if(l==="")return f;if(p.endsWith("/"))return oe(f,de(l))}}};var hr=new Map,Fe=class{packagePath;packageInfo;constructor(t,r){this.packageInfo=t,this.packagePath=r}getPath(){return this.packagePath}resolveExport(t,r){if(!r?.workspaceExportsVisited?.has(this.getPath()))return tt(t,this.exportMapSortedEntries,{sort:!1,...r})}resolveImport(t,r){if(!r?.workspaceImportsVisited?.has(this.getPath()))return tt(t,this.importMapSortedEntries,{sort:!1,...r})}static async fromUrl(t){t=F(t,he());let r=t.href,o=hr.get(r);if(o)return o;let[n,s,i]=q();hr.set(r,n);let a=at(Et(await(await fetch(t,ge)).text())),c=new this(a,r);return s(c),c}},rt=class extends Fe{workspaceChildren;workspaceParents;constructor(t,r){super(t,r),this.workspaceChildren=[],this.workspaceParents=[]}async addWorkspaceChild(t){let r=Ae(this),o=this.getPath(),n=x(t)||t instanceof URL,s=n?F(t,o):void 0,i=n?await r.fromUrl(s):t;this.workspaceChildren.push(i),i.workspaceParents.push(this)}async addWorkspaceParent(t){let r=Ae(this),o=this.getPath(),n=x(t)||t instanceof URL,s=n?F(t,o):void 0,i=n?await r.fromUrl(s):t;this.workspaceParents.push(i),i.workspaceChildren.push(this)}resolveWorkspaceExport(t,r){let{workspaceExportsVisited:o=new Set,...n}=r??{},s=this.workspaceChildren,i=this.getPath();if(!o.has(i)){o.add(i);for(let a of s){let c=a.resolveExport(t,{workspaceExportsVisited:o,...n})??a.resolveWorkspaceExport(t,{workspaceExportsVisited:o,...n});if(c!==void 0)return x(c)?[c,a]:c}}}resolveWorkspaceImport(t,r){let{workspaceImportsVisited:o=new Set,...n}=r??{},s=this.workspaceParents,i=this.getPath();if(!o.has(i)){o.add(i);for(let a of s){let c=a.resolveImport(t,{workspaceImportsVisited:o,...n})??a.resolveWorkspaceImport(t,{workspaceImportsVisited:o,...n});if(c!==void 0)return x(c)?[c,a]:c}}}};var xr=new Map,ye=class extends rt{importMapSortedEntries;exportMapSortedEntries;getName(){return this.packageInfo.name??"@no-name/package"}getVersion(){return this.packageInfo.version??"0.0.0"}getPath(){let t=this.packagePath;return t||`${jt}/${this.getName()}/${this.getVersion()}/deno.json`}constructor(t,r){super(t,r);let{exports:o={},imports:n={}}=t,s=x(o)?o.endsWith("/")?{"./":o}:{".":o}:o,i={...n};for(let[a,c]of W(i)){let p=A(a);a!==p&&!(p in i)&&(i[p]=A(c))}this.exportMapSortedEntries=W(s).toSorted(et),this.importMapSortedEntries=W(i).toSorted(et)}resolveExport(t,r){let o=this.getPath();if(r?.workspaceExportsVisited?.has(o))return;let n=this.getName(),s=this.getVersion(),{baseAliasDir:i,basePathDir:a=fe(o).dirpath,...c}=r??{},p=i===void 0?[`jsr:${n}@${s}`,`jsr:${n}`,`${n}`]:[i];for(let u of p){let l=te(t,u)?.replace(/^\/+/,"/");l!==void 0&&(t=u+(l==="/"?"":l));let f=super.resolveExport(t,{baseAliasDir:u,basePathDir:a,...c});if(f)return f}}resolveImport(t,r){let o=this.getPath();if(r?.workspaceImportsVisited?.has(o))return;let n=fe(o).dirpath,s=je(t),i=s?"":void 0;return this.resolveExport(t,{...r,baseAliasDir:i})??super.resolveImport(t,{...r,basePathDir:n})}resolveWorkspaceImport(t,r){return this.resolveWorkspaceExport(t,r)??super.resolveWorkspaceImport(t,r)}static async fromUrl(t){let r=F(t,he()),o=r.href,n=o.startsWith("jsr:"),s=o.endsWith("/");if(n){let{host:f}=B(t);t=await Bo(`jsr:${f}`)}else if(s){let f=ot.map(g=>new URL(g,r)),d=await Te(f);if(!d)throw new Error(`Scan Error! failed to find a "./deno.json(c)" or "./jsr.json(c)" package file in your supplied directory: "${r}".`);t=d}let i=await super.fromUrl(t),a=i.getPath(),c=xr.get(a);if(c)return await c,i;let[p,u,l]=q();return xr.set(a,p),await ut((i.packageInfo.workspace??[]).map(async f=>{let d=A(he(f,a));await i.addWorkspaceChild(d)})),u(),i}},jt="https://jsr.io",ot=["./deno.json","./deno.jsonc","./jsr.json","./jsr.jsonc"],zo=async e=>{let{protocol:t,scope:r,pkg:o,pathname:n,version:s}=B(e);if(t!=="jsr:")throw new Error(`expected path protocol to be "jsr:", found "${t}" instead, for package: "${e}"`);if(!r)throw new Error(`expected jsr package to contain a scope, but found "${r}" instead, for package: "${e}"`);let i=new URL(`@${r}/${o}/meta.json`,jt),a=await(await fetch(i,ge)).json(),c=W(a.versions).filter(([d,{yanked:g}])=>!g).map(([d])=>d),p=Lt(c,s??a.latest);if(!p)throw new Error(`failed to find the desired version "${s}" of the jsr package "${e}", with available versions "${be(a.versions)}"`);let u=new URL(`@${r}/${o}/${p}/`,jt),l=ot.map(d=>new URL(d,u)),f=await Te(l,{method:"HEAD"});if(f)return new URL(f);throw new Error(`Network Error: couldn't locate "${e}"'s package json file. searched in the following locations:
${be(l)}`)},Bo=Nt(zo);var V=console.log,Go=e=>{let t=le(e);return(...r)=>{t(r)}},yr=[],Ho=Go(yr),br=()=>{let e=Be();return(r,...o)=>{let n=e,[s,i]=q();return e=s,n.finally(()=>{i(r(...o))}),s}},vr=e=>(Ke(e)||(e=W(e)),e.map(t=>x(t)?[t,t]:Ke(t)?t:[t.in,t.out]));var ee=[void 0,"","file"],Tt=["base64","binary","copy","css","dataurl","default","empty","file","js","json","jsx","local-css","text","ts","tsx"],nt=(r=>(r[r.CWD=0]="CWD",r[r.ABS_WORKING_DIR=1]="ABS_WORKING_DIR",r))(nt||{});var Ko={filters:[/.*/],initialPluginData:void 0,forceInitialPluginData:!1,enableInheritPluginData:!0,scanAncestralWorkspaces:!1,acceptNamespaces:ee},Pr="<stdin>",Vo=e=>{let{filters:t,initialPluginData:r,forceInitialPluginData:o,enableInheritPluginData:n,scanAncestralWorkspaces:s,acceptNamespaces:i}={...Ko,...e},a=new Set([...i,"oazmi-loader-http"]),c=new Map,p=ue(c),u=Ee(c),l=Re(c),f=Symbol("[oazmi-entry]: already captured by initial-data-injector"),d=Symbol("[oazmi-entry]: already captured by inherit-data-injector"),g=Symbol("[oazmi-entry]: already captured by absolute-path-resolver");return async w=>{let{runtimePackage:G,...Y}=r??{},M=Y,$=r!==void 0;w.onStart(async()=>{M.runtimePackage=await Yo(w,G,s);let k=w.initialOptions.stdin;if(k){let{sourcefile:S=Pr,resolveDir:N=""}=k,P=S===Pr?S:N?oe(N,S):C(S);u(P,M)}});let D=async k=>{let{path:S,pluginData:N,...P}=k,{kind:h,namespace:R}=P;if(h!=="entry-point"||(N??{})[f]||!a.has(R)||N!==void 0&&!o)return;let y=o==="merge"?{...M,...N,[f]:!0}:{...M,[f]:!0},b=await w.resolve(S,{...P,pluginData:y});return b.pluginData??=y,b},L=async k=>{let{path:S,pluginData:N,...P}=k,{importer:h="",namespace:R}=P;if((N??{})[d]||!a.has(R))return;if(N==null&&h!==""){let m=p(C(h));return m?L({...P,path:S,pluginData:m}):void 0}let y={...N,[d]:!0},b=await w.resolve(S,{...P,pluginData:y}),I={...b.pluginData??y,[d]:!1};if(I.resolverConfig?.useInheritPluginData!==!1){let m=C(b.path);l(m)||u(C(b.path),I)}return b.pluginData=I,b},z=async k=>{if((k.pluginData??{})[g]||!a.has(k.namespace))return;let{path:S,namespace:N,...P}=k,h=await w.resolve(S,{...P,namespace:"oazmi-resolver-pipeline"}),{path:R,pluginData:y={},namespace:b}=h,I={...y,[g]:!0},m=await w.resolve(R,{...P,namespace:N,pluginData:I});return m.pluginData={...m.pluginData??I,[g]:!1},m};for(let k of t)$&&w.onResolve({filter:k},D),n&&w.onResolve({filter:k},L),w.onResolve({filter:k},z)}},$t=e=>({name:"oazmi-entry",setup:Vo(e)}),Yo=async(e,t,r=!0)=>{let o,n;if(t)return t instanceof Fe?o=t:(n=x(t)&&K(t)==="relative"?(await e.resolve(t,{kind:"entry-point",namespace:"oazmi-resolver-pipeline",pluginData:{resolverConfig:{useNodeModules:!1}}})).path:t,o=await ye.fromUrl(n).catch(i=>{V(`[resolveRuntimePackage]    : ${i?.message??i}`)})),r&&(o??n)&&await Rr(o?.getPath()??n),o},Rr=async e=>{let t=F("./",e),r=F("../",t);if(r.href===t.href)return;let o=ot.map(s=>new URL(s,t)),n=await Te(o);if(n){let s=await ye.fromUrl(n).catch(i=>{V(`[resolveRuntimePackage]    : workspace file at "${n}" was found, but we failed to load it as a deno package. reason:  ${i?.message??i}`)})}return Rr(r)};var Er={base64:[],binary:[".bin",".dat"],copy:[],css:[".css"],dataurl:[],default:[],empty:[],file:[".jpg",".jpeg",".png",".gif",".svg",".webp",".bmp",".tiff",".ico",".mp4",".webm",".ogg",".avi",".mp3",".wav",".aac"],js:[".js",".mjs",".cjs"],json:[".json"],jsx:[".jsx"],"local-css":[".module.css"],text:[".txt",".html",".md",".xml",".csv"],ts:[".ts",".mts",".cts"],tsx:[".tsx"]};var wr={base64:["application/octet-stream","application/base64"],binary:["application/octet-stream","application/binary","application/x-binary","image/vnd.microsoft.icon"],copy:["application/octet-stream","application/x-copy"],css:["text/css"],dataurl:["application/data-url","text/data-url"],default:[],empty:[],file:["application/octet-stream","application/x-file","image/jpeg","image/png","image/gif","image/svg+xml","image/webp","image/bmp","image/tiff","image/vnd.microsoft.icon","video/mp4","video/webm","video/ogg","video/x-msvideo","audio/mpeg","audio/ogg","audio/wav","audio/x-aac","audio/webm"],js:["application/javascript","text/javascript","application/x-javascript","application/ecmascript","text/ecmascript"],json:["application/json","text/json"],jsx:["application/javascript","text/javascript","application/jsx"],"local-css":["text/css","text/x-css"],text:["text/plain","text/html","text/markdown","text/xml","text/csv"],ts:["application/typescript","text/typescript"],tsx:["application/typescript","text/typescript","application/tsx"]};var qo=W(wr).map(([e,t])=>[e,new Set(t)]),Xo=W(Er).map(([e,t])=>[e,new Set(t)]),Jo=new ke(new Map(qo)),Qo=new ke(new Map(Xo)),Zo=e=>{let[t,...r]=e.split(";"),o=t.trim().toLowerCase();return Jo.rget(o)},en=e=>{let t=e.endsWith(".module.css")?".module.css":fe(e).extname;return Qo.rget(t)},kr=e=>{let{headers:t,url:r}=e,o=t.get("content-type")??"",n=Zo(o)??new Set,s=en(r)??new Set,i=n.intersection(s);return i.size<=0&&(i=s),i.size<=0&&(i=n),i};var tn=e=>{let{defaultLoader:t,acceptLoaders:r=Tt,log:o=!1}=e,n=new Set(r),s=o?o===!0?V:o:void 0;return async i=>{let{path:a,pluginData:c}=i,p=F(a),u=await fetch(p,ge);if(!u.ok)throw new Error(`[urlLoaderFactory]: ERROR: network fetch response for url "${p.href}" was not ok (${u.status}). response header:
${be(u.headers)}`);let l=kr(u),f=n.intersection(l),d=[...f].at(0)??t,g=await u.bytes();return s&&s("[urlLoaderFactory]:",{path:a,path_url:p.href,guessed_loaders:l,preferred_loader:d,args:i}),{contents:g,loader:d,pluginData:c}}},Sr={enabled:!0,resolveAgain:!0},rn={filters:[/^https?\:\/\//,/^file\:\/\//],namespace:"oazmi-loader-http",acceptNamespaces:ee,defaultLoader:"copy",acceptLoaders:void 0,convertFileUriToLocalPath:Sr,log:!1},on=(e={})=>{let{acceptLoaders:t,defaultLoader:r,filters:o,namespace:n,acceptNamespaces:s,log:i,convertFileUriToLocalPath:a}={...rn,...e},c=new Set([...s,n]),p={acceptLoaders:t,defaultLoader:r,log:i},u={...Sr,...a};return async l=>{let{absWorkingDir:f,outdir:d,outfile:g,entryPoints:w,write:G,loader:Y}=l.initialOptions,M=async $=>{let{path:D,pluginData:L,namespace:z,...k}=$,S=z===n?"":z;if(c.has(z))return u.enabled&&K(D)==="file"?u.resolveAgain?l.resolve(Le(D),{...k,pluginData:L,namespace:S}):{path:Le(D),pluginData:L,namespace:S}:{path:D,pluginData:L,namespace:n}};o.forEach($=>{l.onResolve({filter:$},M)}),l.onLoad({filter:/.*/,namespace:n},tn(p))}},Wt=e=>({name:"oazmi-http-plugin",setup:on(e)});var nn={filters:[/^jsr\:/],acceptNamespaces:ee},sn=(e={})=>{let{filters:t,acceptNamespaces:r}={...nn,...e},o=new Set([...r,"oazmi-loader-http"]);return async n=>{let{absWorkingDir:s,outdir:i,outfile:a,entryPoints:c,write:p,loader:u}=n.initialOptions,l=async f=>{if(!o.has(f.namespace))return;let{path:d,pluginData:g={},...w}=f,{importMap:G,runtimePackage:Y,resolverConfig:M={},...$}=g,D=await ye.fromUrl(d),L=B(d).pathname,z=L==="/"?".":de(L),k={baseAliasDir:""},S=D.resolveExport(z,k);if(!S)throw new Error(`failed to resolve the path "${d}" from the deno package: "jsr:${D.getName()}@${D.getVersion()}"`);return n.resolve(S,{...w,pluginData:{...$,runtimePackage:D,resolverConfig:{...M,useNodeModules:!1}}})};t.forEach(f=>{n.onResolve({filter:f},l)})}},zt=e=>({name:"oazmi-jsr-plugin",setup:sn(e)});var Cr={enabled:!0},Ir={enabled:!0,globalImportMap:{}},Nr={enabled:!0},Dr={enabled:!0,resolvePath:he,isAbsolutePath:ce},an={runtimePackage:Cr,importMap:Ir,nodeModules:Nr,relativePath:Dr,namespace:"oazmi-resolver-pipeline",log:!1},cn=e=>{let{runtimePackage:t,importMap:r,nodeModules:o,relativePath:n,namespace:s,log:i}={...an,...e},a={...Cr,...t},c={...Ir,...r},p={...Nr,...o},u={...Dr,...n},l=i?i===!0?V:i:void 0,f="discard-this-namespace",d=/.*/;return async g=>{let w=C(g.initialOptions.absWorkingDir??"./"),G=new Set(g.initialOptions.external),Y=G.size<=0?xe:async P=>{let{path:h,pluginData:R={}}=P,y=G.has(h);return l&&l(`[external-path]    checking: ${h}`+(y?`
>> successfully verified the path to be external`:"")),y?{path:h,external:!0,namespace:f,pluginData:{...R}}:void 0},M=a.enabled===!1?xe:async P=>{if(P.pluginData?.resolverConfig?.useRuntimePackage===!1)return;let{path:h,pluginData:R={}}=P,y=R.runtimePackage,b=y&&!je(h)?y.resolveImport(h)??y.resolveWorkspaceImport(h):void 0,[I,m]=De(b)?b:[b,y];return l&&l(`[runtime-package] resolving: ${h}`+(I?`
>> successfully resolved to: ${I}`:"")),I?{path:I,namespace:f,pluginData:{...R,runtimePackage:m}}:void 0},{globalImportMap:$}=c,D=c.enabled===!1?xe:async P=>{if(P.pluginData?.resolverConfig?.useImportMap===!1)return;let{path:h,pluginData:R={}}=P,y={...$,...R.importMap},b=_r(h,y);return l&&l(`[import-map]      resolving: ${h}`+(b?`
>> successfully resolved to: ${b}`:"")),b?{path:b,namespace:f,pluginData:{...R}}:void 0},{resolvePath:L,isAbsolutePath:z}=u,k=Gt({absWorkingDir:L(A(w))},g),S=p.enabled===!1?xe:async P=>{let{path:h,resolveDir:R,importer:y,pluginData:b={}}=P;if(b.resolverConfig?.useNodeModules===!1||b.resolverConfig?.useRelativePath!==!1&&(je(h)||z(h)))return;let I=L(A(R||w)),m=C(h),v=k({importer:y,path:m,resolveDir:I}),{path:E,namespace:j,pluginData:J,...H}=await v.catch(()=>({}));return l&&l(`[node-module]     resolving: ${h}`+(E?`
>> successfully resolved to: ${E}`:"")),E?{...H,path:E,namespace:f,pluginData:{...b}}:void 0},N=u.enabled===!1?xe:async P=>{if(P.pluginData?.resolverConfig?.useRelativePath===!1)return;let{path:h,importer:R,resolveDir:y,pluginData:b={}}=P,I=L(A(y||w)),m=z(R)?R:oe(I,R),v=L(h,m||void 0);return l&&l(`[absolute-path]   resolving: ${h}`+(v?`
>> successfully resolved to: ${v}`:"")),{path:v,namespace:f,pluginData:{...b}}};g.onResolve({filter:d,namespace:s},Y),g.onResolve({filter:d,namespace:s},M),g.onResolve({filter:d,namespace:s},D),g.onResolve({filter:d,namespace:s},S),g.onResolve({filter:d,namespace:s},N)}},Bt=e=>({name:"oazmi-plugindata-resolvers",setup:cn(e)}),Gt=(e,t)=>{let{absWorkingDir:r}=e,o=n=>s=>{let i=Symbol(),a="the-void",{resolve:c,reject:p,resolveDir:u,importer:l=""}=n,f=K(l),d=f==="local"||f==="file"?F("./",l).href:void 0,g=d??u;g===""&&V('[nodeModulesResolverFactory]: WARNING! received an empty resolve directory ("args.resolveDir").',`
	we will fallback to esbuild's current-working-directory for filling in the "resolveDir" value,`,`
	however, you must be using the "nodeModulesResolverFactory" function incorrectly to have encountered this situation.`,`
	remember, the purpose of this function is to scan for a node-module, starting from a directory that YOU provide.`),s.onResolve({filter:/.*/},async w=>{if(w.pluginData?.[i]===!0)return;let{path:G,external:Y,namespace:M,sideEffects:$,suffix:D}=await s.resolve(re(w.path),{kind:"entry-point",resolveDir:re(g!==""?g:w.resolveDir),pluginData:{[i]:!0}});return c({path:C(G),external:Y,namespace:M,sideEffects:$,suffix:D}),{path:"does-not-matter.js",namespace:a}}),s.onLoad({filter:/.*/,namespace:a},()=>({contents:"",loader:"empty"}))};return async n=>{let{path:s,resolveDir:i="",importer:a}=n,c=i===""?r??"":i,[p,u,l]=q(),f={name:"native-esbuild-resolver-capture",setup:o({resolve:u,reject:l,resolveDir:c,importer:a})};return await t.esbuild.build({entryPoints:[s],absWorkingDir:r,bundle:!1,minify:!1,write:!1,outdir:"./temp/",plugins:[f]}).catch(()=>{l("esbuild's native resolver failed to resolve the path")}),p}};var pn={dir:1,command:e=>`npm install "${e}" --no-save`},Or=br(),Ar=new Map,Z="npm:",ln={specifiers:[Z],sideEffects:"auto",autoInstall:!0,peerDependencies:{},acceptNamespaces:ee,nodeModulesDirs:[1],log:!1},un=(e={})=>{let{specifiers:t,sideEffects:r,autoInstall:o,peerDependencies:n,acceptNamespaces:s,nodeModulesDirs:i,log:a}={...ln,...e},c=a?a===!0?V:a:void 0,p=new Set([...s,"oazmi-loader-http"]),u=x(r)?void 0:r,l=Ue(o),f=pt(vr(n).map(([d,g])=>{let w=te(d,Z,"")??d,{scope:G,pkg:Y}=B(Z+w),M=(G?"@"+G+"/":"")+Y,$=te(g,Z,"")??g,{host:D}=B(Z+$);return[M,Z+D]}));return ie(l)&&i.unshift(l.dir),async d=>{let{absWorkingDir:g,outdir:w,outfile:G,entryPoints:Y,write:M,loader:$}=d.initialOptions,D=A(_e),L=g?A(C(g)):_e,z=h=>{switch(h){case 0:return D;case 1:return L;default:return Mr(h)}},k=[...new Set(i.map(z))],S=dn(d),N=ie(l)?{dir:z(l.dir),command:l.command,log:a}:l;N&&d.onStart(async()=>{let h=N==="dynamic",R=W(f);!ne(R)&&1&&c&&c("[npmPlugin] peer-dependency: the following peer dependencies were specified:",f);for(let[y,b]of R){let{host:I,version:m}=B(b),v=m===void 0?y===I:I.startsWith(y+"@"),E=`${y}@npm:${I}`,j=v||h?I:E;!v&&h&&(c??V)('[npmPlugin]: WARNING! auto peer dependency package installation under an aliased name is not possible with "autoInstall" set to "dynamic".',`
	this will very likely lead to a broken import. please set "autoInstall" to one of the cli options, such as "auto-cli".`,`
	warning generated for the peer dependency package: "${b}", with alias: "${y}".`),await Or(Lr,j,N)}});let P=h=>async R=>{if(!p.has(R.namespace))return;let{path:y,pluginData:b={},resolveDir:I="",namespace:m,...v}=R,E=te(y,h,Z),{scope:j,pkg:J,pathname:H,version:Pn}=B(E),st=(j?"@"+j+"/":"")+J,We=`${st}${H==="/"?"":H}`,{importMap:Rn,runtimePackage:En,resolverConfig:jr,...Tr}=b,Kt=I===""?k:[I,...k],it=Ar.get(st),Vt;if(it)await it;else{let[Fr,Ur]=q();Ar.set(st,it=Fr),Vt=Ur}let Ce=await S(We,Kt);!Ce&&N&&(await Or(Lr,E,N),Ce=await S(We,Kt)),Ce||(c??V)(`[npmPlugin]: WARNING! no valid "resolveDir" directory was found to contain the npm package named "${We}"`,`
	we will still continue with the path resolution (in case the global-import-map may alter the situation),`,`
	but it is almost guaranteed not to work if the current-working-directory was already part of the scanned directories.`),Vt?.();let Ie=await d.resolve(We,{...v,resolveDir:Ce,namespace:"oazmi-resolver-pipeline",pluginData:{...Tr,resolverConfig:{useRuntimePackage:!1,useImportMap:!1,useNodeModules:!0}}}),Yt=Ie.path;return c&&c(`[npmPlugin]       resolving: "${y}", with resolveDir: "${Ce}"`+(Yt?`
>> successfully resolved to: ${Yt}`:"")),u!==void 0&&(Ie.sideEffects=u),Ie.namespace="",Object.assign(Ie.pluginData.resolverConfig,{...jr,useRuntimePackage:!1,useNodeModules:!0}),Ie};t.forEach(h=>{let R=new RegExp(`^${we(h)}`);d.onResolve({filter:R},P(h))})}},Ht=e=>({name:"oazmi-npm-plugin",setup:un(e)}),Mr=e=>{let t=x(e)?e:e.href,r=K(t),o=me(A(r==="relative"?oe(A(_e),t):t));switch(r){case"local":case"relative":case"file":return re(o);default:throw new Error(`expected a filesystem path, or a "file://" url, but received the incompatible uri scheme "${r}".`)}},dn=e=>{let t=Gt({absWorkingDir:void 0},e),r=async(o,n)=>((await t({path:n,importer:"",resolveDir:o})).path??"")!=="";return async(o,n)=>{let s=n.map(Mr);for(let i of s)if(await r(i,o))return i}},$e=Me(),mn=e=>`deno cache --node-modules-dir="auto" --allow-scripts --no-config "npm:${e}"`,fn=e=>`deno cache --node-modules-dir="auto" --no-config "npm:${e}"`,gn=e=>`npm install "${e}" --no-save`,_n=e=>`bun install "${e}" --no-save`,hn=e=>`pnpm install "${e}"`,Ue=e=>{if(e){if(ie(e))return{...pn,...e};switch(e){case"auto":return $e===_.DENO||$e===_.BUN?"dynamic":Ue("npm");case!0:case"auto-cli":switch($e){case _.DENO:return Ue("deno");case _.BUN:return Ue("bun");case _.NODE:return Ue("npm");default:throw new Error("ERROR! cli-installation of npm-packages is not possible on web-browser runtimes.")}case"dynamic":return"dynamic";case"deno":return{dir:1,command:mn};case"deno-noscript":return{dir:1,command:fn};case"bun":return{dir:1,command:_n};case"npm":return{dir:1,command:gn};case"pnpm":return{dir:1,command:hn};default:return}}},Lr=async(e,t)=>{switch($e){case _.DENO:case _.BUN:case _.NODE:return t==="dynamic"?yn(e):xn(e,t);default:throw new Error("ERROR! npm-package installation is not possible on web-browser runtimes.")}},xn=async(e,t)=>{let{command:r,dir:o,log:n}=t,s=n?n===!0?V:n:void 0,i=B(e.startsWith(Z)?e:Z+e),a=i.host,c=a.includes("@npm:"),p=r(c?e:a);s&&s(`[npmPlugin]      installing: "${e}", in directory "${o}"
>>    using the cli-command: \`${p}\``),await Ct($e,p,{cwd:o})},yn=async e=>{let t=B(e.startsWith(Z)?e:Z+e),r=t.href.replace(/^npm\:[\/\\]*/,Z).slice(0,t.pathname==="/"?-1:void 0),o=`export * as myLib from "${Pe(r)}"`,n=new Blob([o],{type:"text/javascript"});await import(URL.createObjectURL(n))};var bn={initialPluginData:void 0,scanAncestralWorkspaces:!1,log:!1,logFor:["npm","resolver"],autoInstall:!0,peerDependencies:{},nodeModulesDirs:[1],globalImportMap:{},getCwd:_e,acceptNamespaces:ee},vn=e=>{let{acceptNamespaces:t,autoInstall:r,getCwd:o,globalImportMap:n,log:s,logFor:i,peerDependencies:a,nodeModulesDirs:c,initialPluginData:p,scanAncestralWorkspaces:u}={...bn,...e},l=Mt(o,ce);return[$t({initialPluginData:p,scanAncestralWorkspaces:u,acceptNamespaces:t}),Wt({acceptNamespaces:t,log:i.includes("http")?s:!1}),zt({acceptNamespaces:t}),Ht({acceptNamespaces:t,autoInstall:r,peerDependencies:a,nodeModulesDirs:c,log:i.includes("npm")?s:!1}),Bt({log:i.includes("resolver")?s:!1,importMap:{globalImportMap:n},relativePath:{resolvePath:l}})]};export{nt as DIRECTORY,Tt as allEsbuildLoaders,Ho as arrayLogger,yr as arrayLoggerHistory,ee as defaultEsbuildNamespaces,vn as denoPlugins,$t as entryPlugin,Wt as httpPlugin,zt as jsrPlugin,V as logLogger,Ht as npmPlugin,Bt as resolverPlugin};
