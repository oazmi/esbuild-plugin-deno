function zt(e,t,r){let o=r===void 0?t:t.bind(r),n=e.length-1;for(;n>=0;){if(o(e[n],n,e))return n;n--}return-1}function Wt(e,t,r){let o=e.findLastIndex(t,r);return o===-1?void 0:e[o]}Array.prototype.findLastIndex||(Array.prototype.findLastIndex=function(e,t){return zt(this,e,t)});Array.prototype.findLast||(Array.prototype.findLast=function(e,t){return Wt(this,e,t)});Uint8Array.prototype.findLastIndex||(Uint8Array.prototype.findLastIndex=function(e,t){return zt(this,e,t)});Uint8Array.prototype.findLast||(Uint8Array.prototype.findLast=function(e,t){return Wt(this,e,t)});var Dr={},Bt=Or(globalThis,Dr);function Or(e,t){return new Proxy(e,{get(r,o,n){return o in t?t[o]:e[o]},set(r,o,n){return o in t&&delete t[o],e[o]=n,!0},deleteProperty(r,o){let n=!1;return o in t&&(delete t[o],n=!0),o in e&&(delete e[o],n=!0),n},ownKeys(r){let o=Reflect.ownKeys(e),n=Reflect.ownKeys(t),s=new Set(n);return[...o.filter(i=>!s.has(i)),...n]},defineProperty(r,o,n){return o in t&&delete t[o],Reflect.defineProperty(e,o,n),!0},getOwnPropertyDescriptor(r,o){return o in t?Reflect.getOwnPropertyDescriptor(t,o):Reflect.getOwnPropertyDescriptor(e,o)},has(r,o){return o in t||o in e}})}var Ar=Array;var Ht=JSON;var Kt=Number,Le=Object,Gt=Promise;var Vt=Symbol;var oe=e=>e.length===0;var Yt=Ar.isArray;var et=Ht.parse,_e=Ht.stringify;var Ne=Kt.isFinite;var ne=Kt.parseInt,tt=Le.assign;var W=Le.entries;var rt=Le.fromEntries;var ot=Le.keys;var se=()=>{let e,t;return[new Promise((o,n)=>{e=o,t=n}),e,t]};var je=Gt.resolve.bind(Gt);var nt=Vt.iterator;var qt=Vt.toStringTag;var he=encodeURI;var xe=decodeURI;var U;(function(e){e[e.LOG=0]="LOG",e[e.ASSERT=0]="ASSERT",e[e.ERROR=1]="ERROR",e[e.PRODUCTION=1]="PRODUCTION",e[e.MINIFY=1]="MINIFY"})(U||(U={}));var K=(e,t,...r)=>o=>e[t].bind(o,...r);var Te=(e,t,...r)=>e[t].bind(e,...r),st=e=>e.prototype,Xt=st(Array),le=st(Map),it=st(Set);var at=K(Xt,"pop"),ue=K(Xt,"push");var ct=K(it,"add");var pt=K(it,"delete");var lt=K(it,"has");var ut=K(le,"delete"),dt=K(le,"entries"),mt=K(le,"forEach"),de=K(le,"get"),ye=K(le,"has"),ft=K(le,"keys"),be=K(le,"set"),gt=K(le,"values");var Fe=e=>{let t=typeof e;return t==="object"||t==="function"};var ie=e=>typeof e=="object",$e=Yt;var v=e=>typeof e=="string";var $r=/[.*+?^${}()|[\]\\]/g,ve=e=>e.replaceAll($r,"\\$&"),ee=(e,t,r="")=>e.startsWith(t)?r+e.slice(t.length):void 0,Ue=(e,t,r="")=>e.endsWith(t)?(t===""?e:e.slice(0,-t.length))+r:void 0,Ur=`\r
`,O;(function(e){e[e.NONE=0]="NONE",e[e.STRING=1]="STRING",e[e.INLINE_COMMENT=2]="INLINE_COMMENT",e[e.MULTILINE_COMMENT=3]="MULTILINE_COMMENT"})(O||(O={}));var _t=e=>{e=" "+e.replaceAll(Ur,`
`)+" ";let t=e.length-1,r=[],o=ue(r),n=at(r),s=O.NONE;for(let i=1;i<t;i++){let a=e[i];switch(a){case"/":{if(s===O.NONE){let c=e[i+1];if(s=c==="/"?O.INLINE_COMMENT:c==="*"?O.MULTILINE_COMMENT:O.NONE,s!==O.NONE){i++;continue}}break}case"*":{if(s===O.MULTILINE_COMMENT&&(s=e[i+1]==="/"?O.NONE:s,s===O.NONE)){i++;continue}break}case`
`:s=s===O.INLINE_COMMENT?O.NONE:s;case"	":case"\v":case" ":{if(s===O.NONE)continue;break}case'"':{s=s===O.NONE?O.STRING:s===O.STRING?O.NONE:s;break}case"}":case"]":{if(s===O.NONE){let c=n();c!==","&&o(c)}break}}(s===O.NONE||s===O.STRING)&&o(a==="\\"?a+e[++i]:a)}return r.join("")};var zr=W({"node:":"node","npm:":"npm","jsr:":"jsr","blob:":"blob","data:":"data","http://":"http","https://":"https","file://":"file","./":"relative","../":"relative"}),Wr=["blob","data","relative"],Br=["jsr","npm","node"],Gr=["jsr:","npm:","node:"],Y="/",ze="./",ht="../",Hr=/\\/g,Kr=/^[a-z]\:[\/\\]/i,Vr=/^[\/\\]([a-z])\:[\/\\]/i,Yr=/^\/+/;var qr=/\/?[^\/]+$/,Xr=/^(?<basename>.+?)(?<ext>\.[^\.]+)?$/,Jr=/^(?<protocol>jsr:|npm:|node:)(\/*(@(?<scope>[^\/\s]+)\/)?(?<pkg>[^@\/\s]+)(@(?<version>[^\/\r\n\t\f\v]+))?)?(?<pathname>\/.*)?$/,ae=(e,t)=>e.startsWith(t),tr=(e,t)=>e.endsWith(t),xt=e=>ae(e,Y)||ae(e,"~")||Kr.test(e),q=e=>{if(!(!e||e==="")){for(let[t,r]of zr)if(ae(e,t))return r;return xt(e)?"local":"relative"}},B=e=>{e=xe(v(e)?e:e.href);let{protocol:t,scope:r,pkg:o,version:n,pathname:s}=Jr.exec(e)?.groups??{};if(t===void 0||o===void 0)throw new Error(U.ERROR?"invalid package url format was provided: "+e:"");let i=r||void 0,a=n||void 0,c=s||Y,p=`${i?"@"+i+Y:""}${o}${a?"@"+a:""}`,l=he(`${t}/${p}${c}`);return{protocol:t,scope:i,pkg:o,version:a,pathname:c,host:p,href:l}},M=(e,t)=>{if(!v(e))return e;e=P(e);let r=t;if(v(t)&&t!==""){let l=q(t);if(Wr.includes(l))throw new Error(U.ERROR?"the following base scheme (url-protocol) is not supported: "+l:"");r=M(t)}let o=q(e),n=r?r.protocol:void 0,s=Br.includes(o),i=Gr.includes(n),a=ae(e,"/"),c=o==="local",p=o==="relative";if(s)return new URL(B(e).href);if(r&&i&&(a||p)){let{host:l,protocol:u,pathname:_}=B(r);if(a)return new URL(`${u}/${he(l)}${he(e)}`);if(p){let m=new URL(e,"x:"+_).pathname;return new URL(`${u}/${he(l)}${m}`)}}return r&&(a||p)?new URL(e,r):c?new URL("file://"+he(e)):new URL(e)},Qr=e=>e.replace(Yr,"");var me=e=>ae(e,ze)?e:ae(e,Y)?"."+e:ze+e,T=e=>tr(e,Y)?e:e+Y;var rr=(e,t={})=>{let{keepRelative:r=!0}=ie(t)?t:{},o=e.split(Y),n=o.at(-1),s=[".."],i=r&&o[0]===".";o.length>=2&&(n==="."||n==="..")&&o.push("");for(let c of o)c===".."?s.at(-1)!==".."?s.pop():s.push(c):c!=="."&&s.push(c);return s.shift(),i&&s[0]!==".."&&s.unshift("."),s.join(Y)},ce=(e,t)=>rr(P(e),t),P=e=>e.replaceAll(Hr,Y);var er=e=>Qr(qr.exec(e)?.[0]??""),Zr=e=>{let{basename:t="",ext:r=""}=Xr.exec(e)?.groups??{};return[t,r]},We=e=>{let t=ce(e),r=er(t),o=r.length,n=o>0?t.slice(0,-o):t,s=er(n.slice(0,-1)),[i,a]=Zr(r);return{path:t,dirpath:n,dirname:s,filename:r,basename:i,extname:a}},Ie=e=>{if(v(e)){if(q(e)!=="file")return;e=new URL(e)}return ae(e.protocol,"file:")?P(xe(e.pathname)).replace(Vr,"$1:/"):void 0},te=e=>{let t=v(e);return Ie(e)??(t?P(e):e.href)};var or=(...e)=>{e=e.map(r=>r==="."?ze:r===".."?ht:r);let t=e.reduce((r,o)=>{let n=r.pop(),s=tr(n,Y),i=s?n:n+Y;if(!s){let a=ae(o,ze),c=ae(o,ht);a?o="."+o:c&&(o=ht+o)}return r.push(i,o),r},[Y]);return t.shift(),rr(t.join(""))},re=(...e)=>or(...e.map(P)),eo=(e,t=xt)=>{let r=v(e)?()=>e:e;return(...o)=>{let n=o.findLastIndex(t);return n>=0?o=o.slice(n):o.unshift(T(r())),or(...o)}},yt=(e,t=xt)=>{v(e)&&(e=P(e));let r=v(e)?()=>e:()=>P(e()),o=eo(r,t);return(...n)=>o(...n.map(P))};var f;(function(e){e[e.DENO=0]="DENO",e[e.BUN=1]="BUN",e[e.NODE=2]="NODE",e[e.CHROMIUM=3]="CHROMIUM",e[e.EXTENSION=4]="EXTENSION",e[e.WEB=5]="WEB",e[e.WORKER=6]="WORKER"})(f||(f={}));var z=Bt,to={[f.DENO]:()=>!!z.Deno?.version,[f.BUN]:()=>!!z.Bun?.version,[f.NODE]:()=>!!z.process?.versions,[f.CHROMIUM]:()=>!!z.chrome?.runtime,[f.EXTENSION]:()=>!!z.browser?.runtime,[f.WEB]:()=>!!z.window?.document,[f.WORKER]:()=>!!(ie(z.self)&&Fe(z.WorkerGlobalScope)&&z.self instanceof z.WorkerGlobalScope)},ro=[f.DENO,f.BUN,f.NODE,f.CHROMIUM,f.EXTENSION,f.WEB,f.WORKER],ke=()=>{for(let e of ro)if(to[e]())return e;throw new Error(U.ERROR?`failed to detect current javascript runtime!
please report this issue to "https://github.com/omar-azmi/kitchensink_ts/issues", along with information on your runtime environment.`:"")},nr=e=>{switch(e){case f.DENO:return z.Deno;case f.BUN:return z.Bun;case f.NODE:return z.process;case f.CHROMIUM:return z.chrome;case f.EXTENSION:return z.browser;case f.WEB:return z.window;case f.WORKER:return z.self;default:throw new Error(U.ERROR?`an invalid runtime enum was provided: "${e}".`:"")}},sr=(e,t=!0)=>{let r=nr(e);if(!r)throw new Error(U.ERROR?`the requested runtime associated with the enum "${e}" is undefined (i.e. you're running on a different runtime from the provided enum).`:"");switch(e){case f.DENO:case f.BUN:case f.NODE:return P(r.cwd());case f.CHROMIUM:case f.EXTENSION:return r.runtime.getURL("");case f.WEB:case f.WORKER:return new URL("./",t?r.location.href:r.location.origin).href}};var oo={args:[]},bt=async(e,t,r={})=>{let{args:o,cwd:n,signal:s}={...oo,...r},i=oe(o);if(!nr(e))throw new Error(U.ERROR?`the requested runtime associated with the enum "${e}" is undefined (i.e. you're running on a different runtime from the provided enum).`:"");if(!t&&i)return{stdout:"",stderr:""};switch(e){case f.DENO:case f.BUN:case f.NODE:{let{exec:c}=await io(),p=i?t:`${t} ${o.join(" ")}`,[l,u,_]=se();return c(p,{cwd:n?te(n):void 0,signal:s},(m,d,A)=>{m&&_(m.message),u({stdout:d,stderr:A})}),l}default:throw new Error(U.ERROR?`your non-system runtime environment enum ("${e}") does not support shell commands`:"")}};var no;var so=async()=>import("node:child_process"),io=async()=>no??=await so();var ao=["size","mtime","atime","birthtime","ctime","dev","mode"],Es=["isFile","isDirectory","isSymlink",...ao];var vt=e=>{let t=[];e.forEach(n=>{t.push(...n)});let r=new Map([...new Set(t)].map(n=>[n,new Set])),o=de(r);for(let[n,s]of e)s.forEach(i=>o(i).add(n));return r},Pe=class{constructor(t,r){let o=t??(r?vt(r):new Map),n=r??(t?vt(t):new Map),s=be(o),i=be(n),a=ut(o),c=ut(n),p=o.size,l=n.size,u=mt(o),_=mt(n),m=de(o),d=de(n),A=ye(o),G=ye(n),j=dt(o),L=dt(n),D=ft(o),N=ft(n),H=gt(o),E=gt(n),S=(g,...R)=>{let w=m(g)??(s(g,new Set)&&m(g)),F=lt(w),J=ct(w);for(let V of R)F(V)||(J(V),d(V)?.add(g)||i(V,new Set([g])))},x=(g,...R)=>{let w=d(g)??(i(g,new Set)&&d(g)),F=lt(w),J=ct(w);for(let V of R)F(V)||(J(V),m(V)?.add(g)||s(V,new Set([g])))},h=()=>{o.clear(),n.clear()},C=(g,R=!1)=>{let w=m(g);if(w){for(let F of w)d(F).delete(g);R?w.clear():R=a(g)}return R},b=(g,R=!1)=>{let w=d(g);if(w){for(let F of w)m(F).delete(g);R?w.clear():R=c(g)}return R};tt(this,{fmap:o,rmap:n,size:p,rsize:l,forEach:u,rforEach:_,get:m,rget:d,has:A,rhas:G,entries:j,rentries:L,keys:D,rkeys:N,values:H,rvalues:E,add:S,radd:x,clear:h,delete:C,rdelete:b,remove:(g,...R)=>{let w=m(g);if(w){let F=pt(w);for(let J of R)F(J)&&d(J).delete(g)}},rremove:(g,...R)=>{let w=d(g);if(w){let F=pt(w);for(let J of R)F(J)&&m(J).delete(g)}},set:(g,R)=>(C(g,!0),S(g,...R),this),rset:(g,R)=>(b(g,!0),x(g,...R),this),[nt]:j,[qt]:"InvertibleMap"})}};var Be=class{wmap=new WeakMap;smap=new Map;pick(t){return Fe(t)?this.wmap:this.smap}get(t){return this.pick(t).get(t)}set(t,r){return this.pick(t).set(t,r),this}has(t){return this.pick(t).has(t)}delete(t){return this.pick(t).delete(t)}},co=Symbol(U.MINIFY||"represents an unset value for a tree");var Ks=Symbol(U.MINIFY||"a rejection by a throttled function"),Vs=Symbol(U.MINIFY||"a timeout by an awaited promiseTimeout function");var po=(e,t=!1)=>{let r=t?new Be:new Map,o=Te(r,"get"),n=Te(r,"set"),s=Te(r,"has");return{fn:a=>{let c=s(a),p=c?o(a):e(a);return c||n(a,p),p},memory:r}},Pt=e=>po(e).fn;var Ge="x|0|[1-9]\\d*",lo=`(?<major>${Ge})\\.(?<minor>${Ge})\\.(?<patch>${Ge})`,uo="(?<prerelease>[^\\+\\s]*)",mo="(?<build>[^\\s]*)",ir=new RegExp(`${lo}(?:\\-${uo})?(?:\\+${mo})?`),fo=/^\=*v*\s*/i,go=/^[xX\\*]$/,_o=/\-|\+/,ho=new RegExp(`^${Ge}$`),xo="<=|>=|!=|<|>|=|\\^|\\~",yo=new RegExp(`^(?<operator>${xo})?\\s*(?<semver>.*)$`),Et=(e,t)=>e>t?1:e===t?0:-1,bo=e=>{let t=ir.exec(e);if(!t)return;let{major:r="0",minor:o="0",patch:n="0",prerelease:s="",build:i=""}=t.groups,a=ne(r),c=ne(o),p=ne(n);return Ne(a)&&Ne(c)&&Ne(p)?{major:a,minor:c,patch:p,prerelease:s,build:i}:void 0},He=e=>e.trim().replace(fo,""),Ke=e=>bo(He(e)),vo=e=>{let{major:t="x",minor:r="x",patch:o="x",build:n="",prerelease:s=""}=e;return`${t}.${r}.${o}`+(s?"-"+s:"")+(n?"+"+n:"")},ar=(e,t)=>{e=v(e)?Ke(e):e,t=v(t)?Ke(t):t;let{major:r,minor:o,patch:n}=e,{major:s,minor:i,patch:a}=t;return r!==s?Et(r,s):o!==i?Et(o,i):Et(n,a)},Po=e=>e.map(r=>v(r)?Ke(r):r).toSorted(ar),Eo=e=>{let t="x",r=e.search(_o),o=r>=0?e[r]:"-",[n="",s=""]=e.split(o,2),i=n.split(".").toReversed(),a=[],c=oe(i);for(let p=0;p<3;p++){let l=i.pop()||t,u=go.test(l)?t:l;c||=!ho.test(u),a.push(c?t:u)}return a.join(".")+(s?o+s:"")},Ro=e=>{let t=yo.exec(e),r="x";if(!t)throw new Error(`[semver]: invalid comparator: "${e}"`);let{operator:o="",semver:n=""}=t.groups,s=o||"=",i=ir.exec(Eo(He(n)));if(!i)throw new Error(`[semver]: error parsing semver: "${n}"`);let{major:a=r,minor:c=r,patch:p=r,prerelease:l="",build:u=""}=i.groups,_=a===r?void 0:ne(a),m=c===r?void 0:ne(c),d=p===r?void 0:ne(p);return{operator:s,major:_,minor:m,patch:d,prerelease:l,build:u}},Rt={tokenExp:"[OR]",parseExp:/\s*\|\|\s*/g,lexer(e){return e.split(this.tokenExp)}},Ve={tokenExp:"[HYPHEN]",parseExp:/\s+\-\s+/g,lexer(e){let t=e.match(wo);if(!t)return;let r=He(t[1]),o=He(t[2]);return[r,o]}},wo=new RegExp(`^(.+?)${ve(Ve.tokenExp)}(.+?)$`),wt={tokenExp:"[AND]",parseExp:/\s+/g,lexer(e){return e.split(this.tokenExp)}},So=["=","!=",">=","<=",">","<","~","^"],Co=[">","<","!="],No=e=>{for(let t of So)e=e.replaceAll(new RegExp(`${ve(t)}\\s*`,"g"),t);return e},Ee=e=>{if(v(e)){let a=Ve.lexer(e);if(a){let[c,p]=a;return[...Ee(`>=${c}`),...Ee(`<=${p}`)]}e=Ro(e)}let{operator:t="=",major:r,minor:o,patch:n,prerelease:s,build:i}=e;if(r===void 0)return Co.includes(t)?[{operator:"=",major:-1,minor:-1,patch:-1}]:[{operator:">=",major:0,minor:0,patch:0}];if(o===void 0)switch(t){case"!=":return[{operator:"<",major:r,minor:0,patch:0},{operator:">=",major:r+1,minor:0,patch:0}];case"<":return[{operator:"<",major:r,minor:0,patch:0}];case"<=":return[{operator:"<",major:r+1,minor:0,patch:0}];case">":return[{operator:">=",major:r+1,minor:0,patch:0}];case">=":return[{operator:">=",major:r,minor:0,patch:0}];default:return Ee({operator:"^",major:r,minor:0,patch:0})}if(n===void 0)switch(t){case"!=":return[{operator:"<",major:r,minor:o,patch:0},{operator:">=",major:r,minor:o+1,patch:0}];case"<":return[{operator:"<",major:r,minor:o,patch:0}];case"<=":return[{operator:"<",major:r,minor:o+1,patch:0}];case">":return[{operator:">=",major:r,minor:o+1,patch:0}];case">=":return[{operator:">=",major:r,minor:o,patch:0}];case"^":if(r>0||o>0)return Ee({operator:"^",major:r,minor:o,patch:0});default:return Ee({operator:"~",major:r,minor:o,patch:0})}switch(t){case"^":{let a,c;return r>0?(a={operator:">=",major:r,minor:o,patch:n,prerelease:s,build:i},c={operator:"<",major:r+1,minor:0,patch:0}):o>0?(a={operator:">=",major:0,minor:o,patch:n,prerelease:s,build:i},c={operator:"<",major:0,minor:o+1,patch:0}):(a={operator:"=",major:0,minor:0,patch:n,prerelease:s,build:i},c=a),[a,c]}case"~":{let a={operator:">=",major:r,minor:o,patch:n,prerelease:s,build:i},c={operator:"<",major:r,minor:o+1,patch:0};return[a,c]}default:return[{operator:t,major:r,minor:o,patch:n,prerelease:s,build:i}]}},cr=e=>{let t=No(e).replaceAll(Rt.parseExp,Rt.tokenExp).replaceAll(Ve.parseExp,Ve.tokenExp).replaceAll(wt.parseExp,wt.tokenExp),r=[];for(let o of Rt.lexer(t)){let n=[];r.push(n);let s=wt.lexer(o).map(Ee).flat(1);n.push(...s)}return r},Io=[["=","<=",">="],["!=",">",">="],["!=","<","<="]],ko=(e,t)=>{e=v(e)?Ke(e):e,t=v(t)?cr(t):t;for(let r of t){let o=!0;for(let n of r){let s=n.operator,i=ar(e,n);if(Io.at(i).includes(s)===!1||n.major<0){o=!1;break}}if(o)return!0}return!1},St=(e,t)=>{t=v(t)?cr(t):t;let r=Po(e).toReversed();for(let o of r)if(ko(o,t))return vo(o)};var pe=e=>(q(e)??"relative")!=="relative",Ct=(e,t=pe)=>{let r=yt(e,t);return(o,n)=>{if(!o)return r();if(o.startsWith("/")&&n)return te(M(o,n));if(pe(o))return P(o);let s=me(o);return n?r(n,s):r(s)}},fe={redirect:"follow",cache:"force-cache"},ge=T(P(sr(ke(),!0))),Ye=Ct(ge,pe),De=()=>{};var pr=(e,t)=>{e=ce(e);let r=t[e];if(r)return r;let o=ot(t).filter(n=>n.endsWith("/")).toSorted((n,s)=>s.length-n.length);for(let n of o)if(e.startsWith(n)){let s=t[n];if(!s.endsWith("/"))throw new Error(`the value ("${s}") of the matched import-map key ("${n}") for the path alias "${e}" MUST end with a trailing slash ("/") to be specification compliant.`);return e.replace(n,s)}},qe=([e,t],[r,o])=>r.length-e.length,Do={baseAliasDir:"",basePathDir:"",sort:!0,errorCheck:!0},Xe=(e,t,r)=>{let{baseAliasDir:o,basePathDir:n,errorCheck:s,sort:i}={...Do,...r};o=Ue(o,"/")??o,n=Ue(n,"/")??n;let a=ee(ce(e),o),c=a===""||o!==""&&a?.startsWith("/")?"."+a:a;if(c===void 0)return Xe(e,t,{baseAliasDir:"",basePathDir:n,errorCheck:s,sort:i});i&&(t=t.toSorted(qe));for(let[p,l]of t){let u=ee(c,p);if(u!==void 0){if(s&&p.endsWith("/")&&!l.endsWith("/"))throw new Error(`the value ("${l}") of the matched import-map key ("${p}") for the path alias "${e}" MUST end with a trailing slash ("/") to be specification compliant.`);let _=n===""||pe(l)?l:re(T(n),l);if(u==="")return _;if(p.endsWith("/"))return re(_,me(u))}}};var Re=class{packagePath;packageInfo;constructor(t,r){this.packageInfo=t,this.packagePath=r}getPath(){return this.packagePath}resolveExport(t,r){return Xe(t,this.exportMapSortedEntries,{sort:!1,...r})}resolveImport(t,r){return Xe(t,this.importMapSortedEntries,{sort:!1,...r})}static async fromUrl(t){t=M(t,Ye());let r=et(_t(await(await fetch(t,fe)).text()));return new this(r,t.href)}};var lr=e=>ce(e.endsWith("/")?e:e+"/../"),we=class extends Re{importMapSortedEntries;exportMapSortedEntries;getName(){return this.packageInfo.name}getVersion(){return this.packageInfo.version}getPath(){let t=this.packagePath;return t||`${Nt}/${this.getName()}/${this.getVersion()}/deno.json`}constructor(t,r){super(t,r);let{exports:o={},imports:n={}}=t,s=v(o)?o.endsWith("/")?{"./":o}:{".":o}:o,i={...n};for(let[a,c]of W(i)){let p=T(a);a!==p&&!(p in i)&&(i[p]=T(c))}this.exportMapSortedEntries=W(s).toSorted(qe),this.importMapSortedEntries=W(i).toSorted(qe)}resolveExport(t,r){let o=this.getName(),n=this.getVersion(),s=P(this.getPath()),{baseAliasDir:i=`jsr:${o}@${n}`,basePathDir:a=lr(s),...c}=r??{},p=ee(t,i)?.replace(/^\/+/,"/");return p!==void 0&&(t=i+(p==="/"?"":p)),super.resolveExport(t,{baseAliasDir:i,basePathDir:a,...c})}resolveImport(t,r){let o=this.getName(),n=this.getVersion(),s=P(this.getPath()),i=lr(s),a=t.startsWith("./")||t.startsWith("../"),c=a?[""]:[`jsr:${o}@${n}`,`jsr:${o}`,`${o}`],p;for(let l of c)if(p=this.resolveExport(t,{...r,baseAliasDir:l}),p)break;return p??super.resolveImport(t,{...r,basePathDir:i})}static async fromUrl(t){if((v(t)?t:t.href).startsWith("jsr:")){let{host:n}=B(t);t=await Mo(`jsr:${n}`)}return super.fromUrl(t)}},Nt="https://jsr.io",Oo=async e=>{let{protocol:t,scope:r,pkg:o,pathname:n,version:s}=B(e);if(t!=="jsr:")throw new Error(`expected path protocol to be "jsr:", found "${t}" instead, for package: "${e}"`);if(!r)throw new Error(`expected jsr package to contain a scope, but found "${r}" instead, for package: "${e}"`);let i=M(`@${r}/${o}/meta.json`,Nt),a=await(await fetch(i,fe)).json(),c=W(a.versions).filter(([L,{yanked:D}])=>!D).map(([L])=>L),p=St(c,s??a.latest);if(!p)throw new Error(`failed to find the desired version "${s}" of the jsr package "${e}", with available versions "${_e(a.versions)}"`);let l=M(`@${r}/${o}/${p}/`,Nt),u=M("./deno.json",l),_=M("./deno.jsonc",l),m=M("./jsr.json",l),d=M("./jsr.jsonc",l),A=M("./package.json",l),G=M("./package.jsonc",l),j=[u,_,m,d];for(let L of j)if((await fetch(L,{...fe,method:"HEAD"})).ok)return L;throw new Error(`Network Error: couldn't locate "${e}"'s package json file. searched in the following locations:
${_e(j)}`)},Mo=Pt(Oo);var Q=[void 0,"","file"],It=["base64","binary","copy","css","dataurl","default","empty","file","js","json","jsx","local-css","text","ts","tsx"],Je=(r=>(r[r.CWD=0]="CWD",r[r.ABS_WORKING_DIR=1]="ABS_WORKING_DIR",r))(Je||{});var Ao={filters:[/.*/],initialPluginData:void 0,forceInitialPluginData:!1,enableInheritPluginData:!0,acceptNamespaces:Q},ur="<stdin>",Lo=e=>{let{filters:t,initialPluginData:r,forceInitialPluginData:o,enableInheritPluginData:n,acceptNamespaces:s}={...Ao,...e},i=new Set([...s,"oazmi-loader-http"]),a=new Map,c=de(a),p=be(a),l=ye(a),u=Symbol("[oazmi-entry]: already captured by initial-data-injector"),_=Symbol("[oazmi-entry]: already captured by inherit-data-injector"),m=Symbol("[oazmi-entry]: already captured by absolute-path-resolver");return async d=>{let{runtimePackage:A,...G}=r??{},j=G,L=r!==void 0;d.onStart(async()=>{j.runtimePackage=await jo(d,A);let E=d.initialOptions.stdin;if(E){let{sourcefile:S=ur,resolveDir:x=""}=E,h=S===ur?S:x?re(x,S):P(S);p(h,j)}});let D=async E=>{let{path:S,pluginData:x,...h}=E,{kind:C,namespace:b}=h;if(C!=="entry-point"||(x??{})[u]||!i.has(b)||x!==void 0&&!o)return;let y=o==="merge"?{...j,...x,[u]:!0}:{...j,[u]:!0},k=await d.resolve(S,{...h,pluginData:y});return k.pluginData??=y,k},N=async E=>{let{path:S,pluginData:x,...h}=E,{importer:C="",namespace:b}=h;if((x??{})[_]||!i.has(b))return;if(x==null&&C!==""){let I=c(P(C));return I?N({...h,path:S,pluginData:I}):void 0}let y={...x,[_]:!0},k=await d.resolve(S,{...h,pluginData:y}),$={...k.pluginData??y,[_]:!1};if($.resolverConfig?.useInheritPluginData!==!1){let I=P(k.path);l(I)||p(P(k.path),$)}return k.pluginData=$,k},H=async E=>{if((E.pluginData??{})[m]||!i.has(E.namespace))return;let{path:S,namespace:x,...h}=E,C=await d.resolve(S,{...h,namespace:"oazmi-resolver-pipeline"}),{path:b,pluginData:y={},namespace:k}=C,$={...y,[m]:!0},I=await d.resolve(b,{...h,namespace:x,pluginData:$});return I.pluginData={...I.pluginData??$,[m]:!1},I};for(let E of t)L&&d.onResolve({filter:E},D),n&&d.onResolve({filter:E},N),d.onResolve({filter:E},H)}},Ot=e=>({name:"oazmi-entry",setup:Lo(e)}),jo=async(e,t)=>{let r=t!==void 0,o=t instanceof Re,n=!r||o?void 0:v(t)?M((await e.resolve(t,{kind:"entry-point",namespace:"oazmi-resolver-pipeline",pluginData:{resolverConfig:{useNodeModules:!1}}})).path):t;return r?o?t:await we.fromUrl(n):void 0};var dr={base64:[],binary:[".bin",".dat"],copy:[],css:[".css"],dataurl:[],default:[],empty:[],file:[".jpg",".jpeg",".png",".gif",".svg",".webp",".bmp",".tiff",".ico",".mp4",".webm",".ogg",".avi",".mp3",".wav",".aac"],js:[".js",".mjs",".cjs"],json:[".json"],jsx:[".jsx"],"local-css":[".module.css"],text:[".txt",".html",".md",".xml",".csv"],ts:[".ts",".mts",".cts"],tsx:[".tsx"]};var mr={base64:["application/octet-stream","application/base64"],binary:["application/octet-stream","application/binary","application/x-binary","image/vnd.microsoft.icon"],copy:["application/octet-stream","application/x-copy"],css:["text/css"],dataurl:["application/data-url","text/data-url"],default:[],empty:[],file:["application/octet-stream","application/x-file","image/jpeg","image/png","image/gif","image/svg+xml","image/webp","image/bmp","image/tiff","image/vnd.microsoft.icon","video/mp4","video/webm","video/ogg","video/x-msvideo","audio/mpeg","audio/ogg","audio/wav","audio/x-aac","audio/webm"],js:["application/javascript","text/javascript","application/x-javascript","application/ecmascript","text/ecmascript"],json:["application/json","text/json"],jsx:["application/javascript","text/javascript","application/jsx"],"local-css":["text/css","text/x-css"],text:["text/plain","text/html","text/markdown","text/xml","text/csv"],ts:["application/typescript","text/typescript"],tsx:["application/typescript","text/typescript","application/tsx"]};var To=W(mr).map(([e,t])=>[e,new Set(t)]),Fo=W(dr).map(([e,t])=>[e,new Set(t)]),$o=new Pe(new Map(To)),Uo=new Pe(new Map(Fo)),zo=e=>{let[t,...r]=e.split(";"),o=t.trim().toLowerCase();return $o.rget(o)},Wo=e=>{let t=e.endsWith(".module.css")?".module.css":We(e).extname;return Uo.rget(t)},fr=e=>{let{headers:t,url:r}=e,o=t.get("content-type")??"",n=zo(o)??new Set,s=Wo(r)??new Set,i=n.intersection(s);return i.size<=0&&(i=s),i.size<=0&&(i=n),i};var Z=console.log,Bo=e=>{let t=ue(e);return(...r)=>{t(r)}},gr=[],Go=Bo(gr),_r=()=>{let e=je();return(r,...o)=>{let n=e,[s,i]=se();return e=s,n.finally(()=>{i(r(...o))}),s}},hr=e=>($e(e)||(e=W(e)),e.map(t=>v(t)?[t,t]:$e(t)?t:[t.in,t.out]));var Ho=e=>{let{defaultLoader:t,acceptLoaders:r=It,log:o=!1}=e,n=new Set(r),s=o?o===!0?Z:o:void 0;return async i=>{let{path:a,pluginData:c}=i,p=M(a),l=await fetch(p,fe);if(!l.ok)throw new Error(`[urlLoaderFactory]: ERROR: network fetch response for url "${p.href}" was not ok (${l.status}). response header:
${_e(l.headers)}`);let u=fr(l),_=n.intersection(u),m=[..._].at(0)??t,d=await l.bytes();return s&&s("[urlLoaderFactory]:",{path:a,path_url:p.href,guessed_loaders:u,preferred_loader:m,args:i}),{contents:d,loader:m,pluginData:c}}},xr={enabled:!0,resolveAgain:!0},Ko={filters:[/^https?\:\/\//,/^file\:\/\//],namespace:"oazmi-loader-http",acceptNamespaces:Q,defaultLoader:"copy",acceptLoaders:void 0,convertFileUriToLocalPath:xr,log:!1},Vo=(e={})=>{let{acceptLoaders:t,defaultLoader:r,filters:o,namespace:n,acceptNamespaces:s,log:i,convertFileUriToLocalPath:a}={...Ko,...e},c=new Set([...s,n]),p={acceptLoaders:t,defaultLoader:r,log:i},l={...xr,...a};return async u=>{let{absWorkingDir:_,outdir:m,outfile:d,entryPoints:A,write:G,loader:j}=u.initialOptions,L=async D=>{let{path:N,pluginData:H,namespace:E,...S}=D,x=E===n?"":E;if(c.has(E))return l.enabled&&q(N)==="file"?l.resolveAgain?u.resolve(Ie(N),{...S,pluginData:H,namespace:x}):{path:Ie(N),pluginData:H,namespace:x}:{path:N,pluginData:H,namespace:n}};o.forEach(D=>{u.onResolve({filter:D},L)}),u.onLoad({filter:/.*/,namespace:n},Ho(p))}},Mt=e=>({name:"oazmi-http-plugin",setup:Vo(e)});var Yo={filters:[/^jsr\:/],acceptNamespaces:Q},qo=(e={})=>{let{filters:t,acceptNamespaces:r}={...Yo,...e},o=new Set([...r,"oazmi-loader-http"]);return async n=>{let{absWorkingDir:s,outdir:i,outfile:a,entryPoints:c,write:p,loader:l}=n.initialOptions,u=async _=>{if(!o.has(_.namespace))return;let{path:m,pluginData:d={},...A}=_,{importMap:G,runtimePackage:j,resolverConfig:L={},...D}=d,N=await we.fromUrl(m),H=B(m).pathname,E=H==="/"?".":me(H),S=N.resolveExport(E,{baseAliasDir:""});if(!S)throw new Error(`failed to resolve the path "${m}" from the deno package: "jsr:${N.getName()}@${N.getVersion()}"`);return n.resolve(S,{...A,pluginData:{...D,runtimePackage:N,resolverConfig:{...L,useNodeModules:!1}}})};t.forEach(_=>{n.onResolve({filter:_},u)})}},At=e=>({name:"oazmi-jsr-plugin",setup:qo(e)});var yr={enabled:!0},br={enabled:!0,globalImportMap:{}},vr={enabled:!0},Pr={enabled:!0,resolvePath:Ye,isAbsolutePath:pe},Xo={runtimePackage:yr,importMap:br,nodeModules:vr,relativePath:Pr,namespace:"oazmi-resolver-pipeline",log:!1},Jo=e=>{let{runtimePackage:t,importMap:r,nodeModules:o,relativePath:n,namespace:s,log:i}={...Xo,...e},a={...yr,...t},c={...br,...r},p={...vr,...o},l={...Pr,...n},u=i?i===!0?Z:i:void 0,_="discard-this-namespace",m=/.*/;return async d=>{let A=P(d.initialOptions.absWorkingDir??"./"),G=a.enabled===!1?De:async x=>{if(x.pluginData?.resolverConfig?.useRuntimePackage===!1)return;let{path:h,pluginData:C={}}=x,b=C.runtimePackage,y=b&&!h.startsWith("./")&&!h.startsWith("../")?b.resolveImport(h):void 0;return u&&u(`[runtime-package] resolving: ${h}`+(y?`
>> successfully resolved to: ${y}`:"")),y?{path:y,namespace:_,pluginData:{...C}}:void 0},{globalImportMap:j}=c,L=c.enabled===!1?De:async x=>{if(x.pluginData?.resolverConfig?.useImportMap===!1)return;let{path:h,pluginData:C={}}=x,b={...j,...C.importMap},y=pr(h,b);return u&&u(`[import-map]      resolving: ${h}`+(y?`
>> successfully resolved to: ${y}`:"")),y?{path:y,namespace:_,pluginData:{...C}}:void 0},{resolvePath:D,isAbsolutePath:N}=l,H=jt({absWorkingDir:D(T(A))},d),E=p.enabled===!1?De:async x=>{let{path:h,resolveDir:C,importer:b,pluginData:y={}}=x;if(y.resolverConfig?.useNodeModules===!1||y.resolverConfig?.useRelativePath!==!1&&(h.startsWith("./")||h.startsWith("../")||N(h)))return;let k=D(T(C||A)),$=P(h),I=H({importer:b,path:$,resolveDir:k}),{path:g,namespace:R,pluginData:w,...F}=await I.catch(()=>({}));return u&&u(`[node-module]     resolving: ${h}`+(g?`
>> successfully resolved to: ${g}`:"")),g?{...F,path:g,namespace:_,pluginData:{...y}}:void 0},S=l.enabled===!1?De:async x=>{if(x.pluginData?.resolverConfig?.useRelativePath===!1)return;let{path:h,importer:C,resolveDir:b,pluginData:y={}}=x,k=D(T(b||A)),$=N(C)?C:re(k,C),I=D(h,$||void 0);return u&&u(`[absolute-path]   resolving: ${h}`+(I?`
>> successfully resolved to: ${I}`:"")),{path:I,namespace:_,pluginData:{...y}}};d.onResolve({filter:m,namespace:s},G),d.onResolve({filter:m,namespace:s},L),d.onResolve({filter:m,namespace:s},E),d.onResolve({filter:m,namespace:s},S)}},Lt=e=>({name:"oazmi-plugindata-resolvers",setup:Jo(e)}),jt=(e,t)=>{let{absWorkingDir:r}=e,o=n=>s=>{let i=Symbol(),a="the-void",{resolve:c,reject:p,resolveDir:l,importer:u=""}=n,_=q(u),m=_==="local"||_==="file"?M("./",u).href:void 0,d=m??l;d===""&&Z('[nodeModulesResolverFactory]: WARNING! received an empty resolve directory ("args.resolveDir").',`
	we will fallback to esbuild's current-working-directory for filling in the "resolveDir" value,`,`
	however, you must be using the "nodeModulesResolverFactory" function incorrectly to have encountered this situation.`,`
	remember, the purpose of this function is to scan for a node-module, starting from a directory that YOU provide.`),s.onResolve({filter:/.*/},async A=>{if(A.pluginData?.[i]===!0)return;let{path:G,external:j,namespace:L,sideEffects:D,suffix:N}=await s.resolve(te(A.path),{kind:"entry-point",resolveDir:te(d!==""?d:A.resolveDir),pluginData:{[i]:!0}});return c({path:P(G),external:j,namespace:L,sideEffects:D,suffix:N}),{path:"does-not-matter.js",namespace:a}}),s.onLoad({filter:/.*/,namespace:a},()=>({contents:"",loader:"empty"}))};return async n=>{let{path:s,resolveDir:i="",importer:a}=n,c=i===""?r??"":i,[p,l,u]=se(),_={name:"native-esbuild-resolver-capture",setup:o({resolve:l,reject:u,resolveDir:c,importer:a})};return await t.esbuild.build({entryPoints:[s],absWorkingDir:r,bundle:!1,minify:!1,write:!1,outdir:"./temp/",plugins:[_]}).catch(()=>{u("esbuild's native resolver failed to resolve the path")}),p}};var Qo={dir:1,command:e=>`npm install "${e}" --no-save`},Er=_r(),Rr=new Map,X="npm:",Zo={specifiers:[X],sideEffects:"auto",autoInstall:!0,peerDependencies:{},acceptNamespaces:Q,nodeModulesDirs:[1],log:!1},en=(e={})=>{let{specifiers:t,sideEffects:r,autoInstall:o,peerDependencies:n,acceptNamespaces:s,nodeModulesDirs:i,log:a}={...Zo,...e},c=a?a===!0?Z:a:void 0,p=new Set([...s,"oazmi-loader-http"]),l=v(r)?void 0:r,u=Oe(o),_=rt(hr(n).map(([m,d])=>{let A=ee(m,X,"")??m,{scope:G,pkg:j}=B(X+A),L=(G?"@"+G+"/":"")+j,D=ee(d,X,"")??d,{host:N}=B(X+D);return[L,X+N]}));return ie(u)&&i.unshift(u.dir),async m=>{let{absWorkingDir:d,outdir:A,outfile:G,entryPoints:j,write:L,loader:D}=m.initialOptions,N=T(ge),H=d?T(P(d)):ge,E=b=>{switch(b){case 0:return N;case 1:return H;default:return Sr(b)}},S=[...new Set(i.map(E))],x=tn(m),h=ie(u)?{dir:E(u.dir),command:u.command,log:a}:u;h&&m.onStart(async()=>{let b=h==="dynamic",y=W(_);!oe(y)&&1&&c&&c("[npmPlugin] peer-dependency: the following peer dependencies were specified:",_);for(let[k,$]of y){let{host:I,version:g}=B($),R=g===void 0?k===I:I.startsWith(k+"@"),w=`${k}@npm:${I}`,F=R||b?I:w;!R&&b&&(c??Z)('[npmPlugin]: WARNING! auto peer dependency package installation under an aliased name is not possible with "autoInstall" set to "dynamic".',`
	this will very likely lead to a broken import. please set "autoInstall" to one of the cli options, such as "auto-cli".`,`
	warning generated for the peer dependency package: "${$}", with alias: "${k}".`),await Er(wr,F,h)}});let C=b=>async y=>{if(!p.has(y.namespace))return;let{path:k,pluginData:$={},resolveDir:I="",namespace:g,...R}=y,w=ee(k,b,X),{scope:F,pkg:J,pathname:V,version:dn}=B(w),Qe=(F?"@"+F+"/":"")+J,Ae=`${Qe}${V==="/"?"":V}`,{importMap:mn,runtimePackage:fn,resolverConfig:Cr,...Nr}=$,Ft=I===""?S:[I,...S],Ze=Rr.get(Qe),$t;if(Ze)await Ze;else{let[Ir,kr]=se();Rr.set(Qe,Ze=Ir),$t=kr}let Se=await x(Ae,Ft);!Se&&h&&(await Er(wr,w,h),Se=await x(Ae,Ft)),Se||(c??Z)(`[npmPlugin]: WARNING! no valid "resolveDir" directory was found to contain the npm package named "${Ae}"`,`
	we will still continue with the path resolution (in case the global-import-map may alter the situation),`,`
	but it is almost guaranteed not to work if the current-working-directory was already part of the scanned directories.`),$t?.();let Ce=await m.resolve(Ae,{...R,resolveDir:Se,namespace:"oazmi-resolver-pipeline",pluginData:{...Nr,resolverConfig:{useRuntimePackage:!1,useImportMap:!1,useNodeModules:!0}}}),Ut=Ce.path;return c&&c(`[npmPlugin]       resolving: "${k}", with resolveDir: "${Se}"`+(Ut?`
>> successfully resolved to: ${Ut}`:"")),l!==void 0&&(Ce.sideEffects=l),Ce.namespace="",Object.assign(Ce.pluginData.resolverConfig,{...Cr,useRuntimePackage:!1,useNodeModules:!0}),Ce};t.forEach(b=>{let y=new RegExp(`^${ve(b)}`);m.onResolve({filter:y},C(b))})}},Tt=e=>({name:"oazmi-npm-plugin",setup:en(e)}),Sr=e=>{let t=v(e)?e:e.href,r=q(t),o=ce(T(r==="relative"?re(T(ge),t):t));switch(r){case"local":case"relative":case"file":return te(o);default:throw new Error(`expected a filesystem path, or a "file://" url, but received the incompatible uri scheme "${r}".`)}},tn=e=>{let t=jt({absWorkingDir:void 0},e),r=async(o,n)=>((await t({path:n,importer:"",resolveDir:o})).path??"")!=="";return async(o,n)=>{let s=n.map(Sr);for(let i of s)if(await r(i,o))return i}},Me=ke(),rn=e=>`deno cache --node-modules-dir="auto" --allow-scripts --no-config "npm:${e}"`,on=e=>`deno cache --node-modules-dir="auto" --no-config "npm:${e}"`,nn=e=>`npm install "${e}" --no-save`,sn=e=>`bun install "${e}" --no-save`,an=e=>`pnpm install "${e}"`,Oe=e=>{if(e){if(ie(e))return{...Qo,...e};switch(e){case"auto":return Me===f.DENO||Me===f.BUN?"dynamic":Oe("npm");case!0:case"auto-cli":switch(Me){case f.DENO:return Oe("deno");case f.BUN:return Oe("bun");case f.NODE:return Oe("npm");default:throw new Error("ERROR! cli-installation of npm-packages is not possible on web-browser runtimes.")}case"dynamic":return"dynamic";case"deno":return{dir:1,command:rn};case"deno-noscript":return{dir:1,command:on};case"bun":return{dir:1,command:sn};case"npm":return{dir:1,command:nn};case"pnpm":return{dir:1,command:an};default:return}}},wr=async(e,t)=>{switch(Me){case f.DENO:case f.BUN:case f.NODE:return t==="dynamic"?pn(e):cn(e,t);default:throw new Error("ERROR! npm-package installation is not possible on web-browser runtimes.")}},cn=async(e,t)=>{let{command:r,dir:o,log:n}=t,s=n?n===!0?Z:n:void 0,i=B(e.startsWith(X)?e:X+e),a=i.host,c=a.includes("@npm:"),p=r(c?e:a);s&&s(`[npmPlugin]      installing: "${e}", in directory "${o}"
>>    using the cli-command: \`${p}\``),await bt(Me,p,{cwd:o})},pn=async e=>{let t=B(e.startsWith(X)?e:X+e),r=t.href.replace(/^npm\:[\/\\]*/,X).slice(0,t.pathname==="/"?-1:void 0),o=`export * as myLib from "${xe(r)}"`,n=new Blob([o],{type:"text/javascript"});await import(URL.createObjectURL(n))};var ln={initialPluginData:void 0,log:!1,logFor:["npm","resolver"],autoInstall:!0,peerDependencies:{},nodeModulesDirs:[1],globalImportMap:{},getCwd:ge,acceptNamespaces:Q},un=e=>{let{acceptNamespaces:t,autoInstall:r,getCwd:o,globalImportMap:n,log:s,logFor:i,peerDependencies:a,nodeModulesDirs:c,initialPluginData:p}={...ln,...e},l=Ct(o,pe);return[Ot({initialPluginData:p,acceptNamespaces:t}),Mt({acceptNamespaces:t,log:i.includes("http")?s:!1}),At({acceptNamespaces:t}),Tt({acceptNamespaces:t,autoInstall:r,peerDependencies:a,nodeModulesDirs:c,log:i.includes("npm")?s:!1}),Lt({log:i.includes("resolver")?s:!1,importMap:{globalImportMap:n},relativePath:{resolvePath:l}})]};export{Je as DIRECTORY,It as allEsbuildLoaders,Go as arrayLogger,gr as arrayLoggerHistory,Q as defaultEsbuildNamespaces,un as denoPlugins,Ot as entryPlugin,Mt as httpPlugin,At as jsrPlugin,Z as logLogger,Tt as npmPlugin,Lt as resolverPlugin};
