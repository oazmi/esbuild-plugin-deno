var Mr={},Gt=Or(globalThis,Mr);function Or(e,t){return new Proxy(e,{get(r,n,o){return n in t?t[n]:e[n]},set(r,n,o){return n in t&&delete t[n],e[n]=o,!0},deleteProperty(r,n){let o=!1;return n in t&&(delete t[n],o=!0),n in e&&(delete e[n],o=!0),o},ownKeys(r){let n=Reflect.ownKeys(e),o=Reflect.ownKeys(t),s=new Set(o);return[...n.filter(a=>!s.has(a)),...o]},defineProperty(r,n,o){return n in t&&delete t[n],Reflect.defineProperty(e,n,o),!0},getOwnPropertyDescriptor(r,n){return n in t?Reflect.getOwnPropertyDescriptor(t,n):Reflect.getOwnPropertyDescriptor(e,n)},has(r,n){return n in t||n in e}})}var Dr=Array;var zt=JSON;var Ht=Number,Te=Object,je=Promise;var Yt=Symbol;var oe=e=>e.length===0;var Ie=Dr.isArray;var nt=zt.parse,he=zt.stringify;var ke=Ht.isFinite;var se=Ht.parseInt,ot=Te.assign;var j=Te.entries;var st=Te.fromEntries;var Jt=Te.getPrototypeOf;var at=Te.keys;var z=()=>{let e,t;return[new Promise((n,o)=>{e=n,t=o}),e,t]},it=je.all.bind(je);var ct=je.resolve.bind(je);var qt=Yt.iterator;var Qt=Yt.toStringTag;var _e=encodeURI;var ye=decodeURI;var H=(e,t,...r)=>(n=>e[t].bind(n,...r));var Fe=(e,t,...r)=>e[t].bind(e,...r),pt=e=>e.prototype,Xt=pt(Array),ae=pt(Map),lt=pt(Set);var ut=H(Xt,"pop"),xe=H(Xt,"push");var dt=H(lt,"add");var mt=H(lt,"delete");var gt=H(lt,"has");var ft=H(ae,"delete"),ht=H(ae,"entries"),_t=H(ae,"forEach"),ie=H(ae,"get"),be=H(ae,"has"),yt=H(ae,"keys"),ve=H(ae,"set"),xt=H(ae,"values");var Ke=e=>Jt(e).constructor;var $e=e=>{let t=typeof e;return t==="object"||t==="function"};var te=e=>typeof e=="object",Ve=Ie;var _=e=>typeof e=="string";var Ur=/[.*+?^${}()|[\]\\]/g,Re=e=>e.replaceAll(Ur,"\\$&"),X=(e,t,r="")=>e.startsWith(t)?r+e.slice(t.length):void 0,We=(e,t,r="")=>e.endsWith(t)?(t===""?e:e.slice(0,-t.length))+r:void 0,Lr=`\r
`;var bt=e=>{e=" "+e.replaceAll(Lr,`
`)+" ";let t=e.length-1,r=[],n=xe(r),o=ut(r),s=0;for(let a=1;a<t;a++){let i=e[a];switch(i){case"/":{if(s===0){let c=e[a+1];if(s=c==="/"?2:c==="*"?3:0,s!==0){a++;continue}}break}case"*":{if(s===3&&(s=e[a+1]==="/"?0:s,s===0)){a++;continue}break}case`
`:s=s===2?0:s;case"	":case"\v":case" ":{if(s===0)continue;break}case'"':{s=s===0?1:s===1?0:s;break}case"}":case"]":{if(s===0){let c=o();c!==","&&n(c)}break}}(s===0||s===1)&&n(i==="\\"?i+e[++a]:i)}return r.join("")};var Fr=j({"node:":"node","npm:":"npm","jsr:":"jsr","blob:":"blob","data:":"data","http://":"http","https://":"https","file://":"file","./":"relative","../":"relative"}),Kr=["blob","data","relative"],$r=["jsr","npm","node"],Vr=["jsr:","npm:","node:"],J="/",Be="./",vt="../",Wr=/\\/g,Br=/^[a-z]\:[\/\\]/i,Gr=/^[\/\\]([a-z])\:[\/\\]/i,zr=/^\/+/;var Hr=/\/?[^\/]+$/,Yr=/^(?<basename>.+?)(?<ext>\.[^\.]+)?$/,Jr=/^(?<protocol>jsr:|npm:|node:)(\/*(@(?<scope>[^\/\s]+)\/)?(?<pkg>[^@\/\s]+)(@(?<version>[^\/\r\n\t\f\v]+))?)?(?<pathname>\/.*)?$/,re=(e,t)=>e.startsWith(t),er=(e,t)=>e.endsWith(t),Rt=e=>re(e,J)||re(e,"~")||Br.test(e),W=e=>{if(!(!e||e==="")){for(let[t,r]of Fr)if(re(e,t))return r;return Rt(e)?"local":"relative"}},K=e=>{e=ye(_(e)?e:e.href);let{protocol:t,scope:r,pkg:n,version:o,pathname:s}=Jr.exec(e)?.groups??{};if(t===void 0||n===void 0)throw new Error("invalid package url format was provided: "+e);let a=r||void 0,i=o||void 0,c=s||J,p=`${a?"@"+a+J:""}${n}${i?"@"+i:""}`,u=_e(`${t}/${p}${c}`);return{protocol:t,scope:a,pkg:n,version:i,pathname:c,host:p,href:u}},D=(e,t)=>{if(!_(e))return e;e=T(e);let r=t;if(_(t)&&t!==""){let u=W(t);if(Kr.includes(u))throw new Error("the following base scheme (url-protocol) is not supported: "+u);r=D(t)}let n=W(e),o=r?r.protocol:void 0,s=$r.includes(n),a=Vr.includes(o),i=re(e,"/"),c=n==="local",p=n==="relative";if(s)return new URL(K(e).href);if(r&&a&&(i||p)){let{host:u,protocol:l,pathname:g}=K(r);if(i)return new URL(`${l}/${_e(u)}${_e(e)}`);if(p){let d=new URL(e,"x:"+g).pathname;return new URL(`${l}/${_e(u)}${d}`)}}return r&&(i||p)?new URL(e,r):c?new URL("file://"+_e(e)):new URL(e)},qr=e=>e.replace(zr,"");var ce=e=>re(e,Be)?e:re(e,J)?"."+e:Be+e,N=e=>er(e,J)?e:e+J;var tr=(e,t={})=>{let{keepRelative:r=!0}=te(t)?t:{},n=e.split(J),o=n.at(-1),s=[".."],a=r&&n[0]===".";n.length>=2&&(o==="."||o==="..")&&n.push("");for(let c of n)c===".."?s.at(-1)!==".."?s.pop():s.push(c):c!=="."&&s.push(c);return s.shift(),a&&s[0]!==".."&&s.unshift("."),s.join(J)},pe=(e,t)=>tr(T(e),t),T=e=>e.replaceAll(Wr,J);var Zt=e=>qr(Hr.exec(e)?.[0]??""),Qr=e=>{let{basename:t="",ext:r=""}=Yr.exec(e)?.groups??{};return[t,r]},le=e=>{let t=pe(e),r=Zt(t),n=r.length,o=n>0?t.slice(0,-n):t,s=Zt(o.slice(0,-1)),[a,i]=Qr(r);return{path:t,dirpath:o,dirname:s,filename:r,basename:a,extname:i}},we=e=>{if(_(e)){if(W(e)!=="file")return;e=new URL(e)}return re(e.protocol,"file:")?T(ye(e.pathname)).replace(Gr,"$1:/"):void 0},Z=e=>{let t=_(e);return we(e)??(t?T(e):e.href)};var Xr=(e,t)=>{let r=e.pop(),n=er(r,J),o=n?r:r+J;if(!n){let s=re(t,Be),a=re(t,vt);s?t="."+t:a&&(t=vt+t)}return e.push(o,t),e},rr=(...e)=>{e=e.map(r=>r==="."?Be:r===".."?vt:r);let t=e.reduce(Xr,[J]);return t.shift(),tr(t.join(""))},ee=(...e)=>rr(...e.map(T)),Zr=(e,t=Rt)=>{let r=_(e)?(()=>e):e;return(...n)=>{let o=n.findLastIndex(t);return o>=0?n=n.slice(o):n.unshift(N(r())),rr(...n)}},Pt=(e,t=Rt)=>{_(e)&&(e=T(e));let r=_(e)?(()=>e):(()=>T(e())),n=Zr(r,t);return(...o)=>n(...o.map(T))};var U=Gt,en={0:()=>!!U.Deno?.version,1:()=>!!U.Bun?.version,2:()=>!!U.process?.versions,3:()=>!!U.chrome?.runtime,4:()=>!!U.browser?.runtime,5:()=>!!U.window?.document,6:()=>!!(te(U.self)&&$e(U.WorkerGlobalScope)&&U.self instanceof U.WorkerGlobalScope)},tn=[0,1,2,3,4,5,6],Ne=()=>{for(let e of tn)if(en[e]())return e;throw new Error(`failed to detect current javascript runtime!
please report this issue to "https://github.com/omar-azmi/kitchensink_ts/issues", along with information on your runtime environment.`)},nr=e=>{switch(e){case 0:return U.Deno;case 1:return U.Bun;case 2:return U.process;case 3:return U.chrome;case 4:return U.browser;case 5:return U.window;case 6:return U.self;default:throw new Error(`an invalid runtime enum was provided: "${e}".`)}},or=(e,t=!0)=>{let r=nr(e);if(!r)throw new Error(`the requested runtime associated with the enum "${e}" is undefined (i.e. you're running on a different runtime from the provided enum).`);switch(e){case 0:case 1:case 2:return T(r.cwd());case 3:case 4:return r.runtime.getURL("");case 5:case 6:return new URL("./",t?r.location.href:r.location.origin).href}};var rn={args:[]},St=async(e,t,r={})=>{let{args:n,cwd:o,signal:s}={...rn,...r},a=oe(n);if(!nr(e))throw new Error(`the requested runtime associated with the enum "${e}" is undefined (i.e. you're running on a different runtime from the provided enum).`);if(!t&&a)return{stdout:"",stderr:""};switch(e){case 0:case 1:case 2:{let{exec:c}=await sn(),p=a?t:`${t} ${n.join(" ")}`,[u,l,g]=z();return c(p,{cwd:o?Z(o):void 0,signal:s},(d,f,S)=>{d&&g(d.message),l({stdout:f,stderr:S})}),u}default:throw new Error(`your non-system runtime environment enum ("${e}") does not support shell commands`)}};var nn;var on=async()=>import("node:child_process"),sn=async()=>nn??=await on();var an=["size","mtime","atime","birthtime","ctime","dev","mode"],Do=["isFile","isDirectory","isSymlink",...an];var Et=e=>{let t=[];e.forEach(o=>{t.push(...o)});let r=new Map([...new Set(t)].map(o=>[o,new Set])),n=ie(r);for(let[o,s]of e)s.forEach(a=>n(a).add(o));return r},Pe=class{constructor(t,r){let n=t??(r?Et(r):new Map),o=r??(t?Et(t):new Map),s=ve(n),a=ve(o),i=ft(n),c=ft(o),p=n.size,u=o.size,l=_t(n),g=_t(o),d=ie(n),f=ie(o),S=be(n),$=be(o),G=ht(n),O=ht(o),L=yt(n),w=yt(o),M=xt(n),F=xt(o),E=(m,...b)=>{let P=d(m)??(s(m,new Set)&&d(m)),A=gt(P),Y=dt(P);for(let V of b)A(V)||(Y(V),f(V)?.add(m)||a(V,new Set([m])))},C=(m,...b)=>{let P=f(m)??(a(m,new Set)&&f(m)),A=gt(P),Y=dt(P);for(let V of b)A(V)||(Y(V),d(V)?.add(m)||s(V,new Set([m])))},k=()=>{n.clear(),o.clear()},v=(m,b=!1)=>{let P=d(m);if(P){for(let A of P)f(A).delete(m);b?P.clear():b=i(m)}return b},h=(m,b=!1)=>{let P=f(m);if(P){for(let A of P)d(A).delete(m);b?P.clear():b=c(m)}return b};ot(this,{fmap:n,rmap:o,size:p,rsize:u,forEach:l,rforEach:g,get:d,rget:f,has:S,rhas:$,entries:G,rentries:O,keys:L,rkeys:w,values:M,rvalues:F,add:E,radd:C,clear:k,delete:v,rdelete:h,remove:(m,...b)=>{let P=d(m);if(P){let A=mt(P);for(let Y of b)A(Y)&&f(Y).delete(m)}},rremove:(m,...b)=>{let P=f(m);if(P){let A=mt(P);for(let Y of b)A(Y)&&d(Y).delete(m)}},set:(m,b)=>(v(m,!0),E(m,...b),this),rset:(m,b)=>(h(m,!0),C(m,...b),this),[qt]:G,[Qt]:"InvertibleMap"})}};var Ge=class{wmap=new WeakMap;smap=new Map;pick(t){return $e(t)?this.wmap:this.smap}get(t){return this.pick(t).get(t)}set(t,r){return this.pick(t).set(t,r),this}has(t){return this.pick(t).has(t)}delete(t){return this.pick(t).delete(t)}},cn=Symbol(1);var Jo=Symbol(1),qo=Symbol(1);var pn=(e,t=!1)=>{let r=t?new Ge:new Map,n=Fe(r,"get"),o=Fe(r,"set"),s=Fe(r,"has");return{fn:i=>{let c=s(i),p=c?n(i):e(i);return c||o(i,p),p},memory:r}},Ct=e=>pn(e).fn;var ze="x|0|[1-9]\\d*",ln=`(?<major>${ze})\\.(?<minor>${ze})\\.(?<patch>${ze})`,un="(?<prerelease>[^\\+\\s]*)",dn="(?<build>[^\\s]*)",sr=new RegExp(`${ln}(?:\\-${un})?(?:\\+${dn})?`),mn=/^\=*v*\s*/i,gn=/^[xX\\*]$/,fn=/\-|\+/,hn=new RegExp(`^${ze}$`),_n="<=|>=|!=|<|>|=|\\^|\\~",yn=new RegExp(`^(?<operator>${_n})?\\s*(?<semver>.*)$`),Tt=(e,t)=>e>t?1:e===t?0:-1,xn=e=>{let t=sr.exec(e);if(!t)return;let{major:r="0",minor:n="0",patch:o="0",prerelease:s="",build:a=""}=t.groups,i=se(r),c=se(n),p=se(o);return ke(i)&&ke(c)&&ke(p)?{major:i,minor:c,patch:p,prerelease:s,build:a}:void 0},He=e=>e.trim().replace(mn,""),Ye=e=>xn(He(e)),bn=e=>{let{major:t="x",minor:r="x",patch:n="x",build:o="",prerelease:s=""}=e;return`${t}.${r}.${n}`+(s?"-"+s:"")+(o?"+"+o:"")},ar=(e,t)=>{e=_(e)?Ye(e):e,t=_(t)?Ye(t):t;let{major:r,minor:n,patch:o}=e,{major:s,minor:a,patch:i}=t;return r!==s?Tt(r,s):n!==a?Tt(n,a):Tt(o,i)},vn=e=>e.map(r=>_(r)?Ye(r):r).toSorted(ar),Rn=e=>{let r=e.search(fn),n=r>=0?e[r]:"-",[o="",s=""]=e.split(n,2),a=o.split(".").toReversed(),i=[],c=oe(a);for(let p=0;p<3;p++){let u=a.pop()||"x",l=gn.test(u)?"x":u;c||=!hn.test(l),i.push(c?"x":l)}return i.join(".")+(s?n+s:"")},Pn=e=>{let t=yn.exec(e),r="x";if(!t)throw new Error(`[semver]: invalid comparator: "${e}"`);let{operator:n="",semver:o=""}=t.groups,s=n||"=",a=sr.exec(Rn(He(o)));if(!a)throw new Error(`[semver]: error parsing semver: "${o}"`);let{major:i=r,minor:c=r,patch:p=r,prerelease:u="",build:l=""}=a.groups,g=i===r?void 0:se(i),d=c===r?void 0:se(c),f=p===r?void 0:se(p);return{operator:s,major:g,minor:d,patch:f,prerelease:u,build:l}},It={tokenExp:"[OR]",parseExp:/\s*\|\|\s*/g,lexer(e){return e.split(this.tokenExp)}},Je={tokenExp:"[HYPHEN]",parseExp:/\s+\-\s+/g,lexer(e){let t=e.match(Sn);if(!t)return;let r=He(t[1]),n=He(t[2]);return[r,n]}},Sn=new RegExp(`^(.+?)${Re(Je.tokenExp)}(.+?)$`),kt={tokenExp:"[AND]",parseExp:/\s+/g,lexer(e){return e.split(this.tokenExp)}},En=["=","!=",">=","<=",">","<","~","^"],Cn=[">","<","!="],Tn=e=>{for(let t of En)e=e.replaceAll(new RegExp(`${Re(t)}\\s*`,"g"),t);return e},Se=e=>{if(_(e)){let i=Je.lexer(e);if(i){let[c,p]=i;return[...Se(`>=${c}`),...Se(`<=${p}`)]}e=Pn(e)}let{operator:t="=",major:r,minor:n,patch:o,prerelease:s,build:a}=e;if(r===void 0)return Cn.includes(t)?[{operator:"=",major:-1,minor:-1,patch:-1}]:[{operator:">=",major:0,minor:0,patch:0}];if(n===void 0)switch(t){case"!=":return[{operator:"<",major:r,minor:0,patch:0},{operator:">=",major:r+1,minor:0,patch:0}];case"<":return[{operator:"<",major:r,minor:0,patch:0}];case"<=":return[{operator:"<",major:r+1,minor:0,patch:0}];case">":return[{operator:">=",major:r+1,minor:0,patch:0}];case">=":return[{operator:">=",major:r,minor:0,patch:0}];default:return Se({operator:"^",major:r,minor:0,patch:0})}if(o===void 0)switch(t){case"!=":return[{operator:"<",major:r,minor:n,patch:0},{operator:">=",major:r,minor:n+1,patch:0}];case"<":return[{operator:"<",major:r,minor:n,patch:0}];case"<=":return[{operator:"<",major:r,minor:n+1,patch:0}];case">":return[{operator:">=",major:r,minor:n+1,patch:0}];case">=":return[{operator:">=",major:r,minor:n,patch:0}];case"^":if(r>0||n>0)return Se({operator:"^",major:r,minor:n,patch:0});default:return Se({operator:"~",major:r,minor:n,patch:0})}switch(t){case"^":{let i,c;return r>0?(i={operator:">=",major:r,minor:n,patch:o,prerelease:s,build:a},c={operator:"<",major:r+1,minor:0,patch:0}):n>0?(i={operator:">=",major:0,minor:n,patch:o,prerelease:s,build:a},c={operator:"<",major:0,minor:n+1,patch:0}):(i={operator:"=",major:0,minor:0,patch:o,prerelease:s,build:a},c=i),[i,c]}case"~":{let i={operator:">=",major:r,minor:n,patch:o,prerelease:s,build:a},c={operator:"<",major:r,minor:n+1,patch:0};return[i,c]}default:return[{operator:t,major:r,minor:n,patch:o,prerelease:s,build:a}]}},ir=e=>{let t=Tn(e).replaceAll(It.parseExp,It.tokenExp).replaceAll(Je.parseExp,Je.tokenExp).replaceAll(kt.parseExp,kt.tokenExp),r=[];for(let n of It.lexer(t)){let o=[];r.push(o);let s=kt.lexer(n).map(Se).flat(1);o.push(...s)}return r},In=[["=","<=",">="],["!=",">",">="],["!=","<","<="]],kn=(e,t)=>{e=_(e)?Ye(e):e,t=_(t)?ir(t):t;for(let r of t){let n=!0;for(let o of r){let s=o.operator,a=ar(e,o);if(In.at(a).includes(s)===!1||o.major<0){n=!1;break}}if(n)return!0}return!1},wt=(e,t)=>{t=_(t)?ir(t):t;let r=vn(e).toReversed();for(let n of r)if(kn(n,t))return bn(n)};var ne=e=>(W(e)??"relative")!=="relative",Me=e=>e.startsWith("./")||e.startsWith("../"),Nt=(e,t=ne)=>{let r=Pt(e,t);return(n,o)=>{if(!n)return r();if(n.startsWith("/")&&o)return Z(D(n,o));if(ne(n))return T(n);let s=ce(n);return o?r(o,s):r(s)}},ue={redirect:"follow",cache:"force-cache"},de=N(T(or(Ne(),!0))),me=Nt(de,ne),ge=(()=>{});var Nn=async(e,t)=>{for(let r of e){let n=await fetch(r,{...ue,...t}).catch(ge);if(n?.ok)return n;await n?.body?.cancel()}},Oe=async(e,t)=>{let r=await Nn(e,t);if(r){let n=r.url;return r.body?.cancel(),n}};var cr=(e,t)=>{e=pe(e);let r=t[e];if(r)return r;let n=at(t).filter(o=>o.endsWith("/")).toSorted((o,s)=>s.length-o.length);for(let o of n)if(e.startsWith(o)){let s=t[o];if(!s.endsWith("/"))throw new Error(`the value ("${s}") of the matched import-map key ("${o}") for the path alias "${e}" MUST end with a trailing slash ("/") to be specification compliant.`);return e.replace(o,s)}},qe=([e,t],[r,n])=>r.length-e.length,Mn={baseAliasDir:"",basePathDir:"",sort:!0,errorCheck:!0},Qe=(e,t,r)=>{let{baseAliasDir:n,basePathDir:o,errorCheck:s,sort:a}={...Mn,...r};n=We(n,"/")??n,o=We(o,"/")??o;let i=X(pe(e),n),c=i===""||n!==""&&i?.startsWith("/")?"."+i:i;if(c===void 0)return Qe(e,t,{baseAliasDir:"",basePathDir:o,errorCheck:s,sort:a});a&&(t=t.toSorted(qe));for(let[p,u]of t){let l=X(c,p);if(l!==void 0){if(s&&p.endsWith("/")&&!u.endsWith("/"))throw new Error(`the value ("${u}") of the matched import-map key ("${p}") for the path alias "${e}" MUST end with a trailing slash ("/") to be specification compliant.`);let g=o===""||ne(u)?u:ee(N(o),u);if(l==="")return g;if(p.endsWith("/"))return ee(g,ce(l))}}};var pr=new Map,Ae=class{packagePath;packageInfo;constructor(t,r){this.packageInfo=t,this.packagePath=r}getPath(){return this.packagePath}resolveExport(t,r){if(!r?.workspaceExportsVisited?.has(this.getPath()))return Qe(t,this.exportMapSortedEntries,{sort:!1,...r})}resolveImport(t,r){if(!r?.workspaceImportsVisited?.has(this.getPath()))return Qe(t,this.importMapSortedEntries,{sort:!1,...r})}static async fromUrl(t){t=D(t,me());let r=t.href,n=pr.get(r);if(n)return n;let[o,s,a]=z();pr.set(r,o);let i=nt(bt(await(await fetch(t,ue)).text())),c=new this(i,r);return s(c),c}},Xe=class extends Ae{workspaceChildren;workspaceParents;constructor(t,r){super(t,r),this.workspaceChildren=[],this.workspaceParents=[]}async addWorkspaceChild(t){let r=Ke(this),n=this.getPath(),o=_(t)||t instanceof URL,s=o?D(t,n):void 0,a=o?await r.fromUrl(s):t;this.workspaceChildren.push(a),a.workspaceParents.push(this)}async addWorkspaceParent(t){let r=Ke(this),n=this.getPath(),o=_(t)||t instanceof URL,s=o?D(t,n):void 0,a=o?await r.fromUrl(s):t;this.workspaceParents.push(a),a.workspaceChildren.push(this)}resolveWorkspaceExport(t,r){let{workspaceExportsVisited:n=new Set,...o}=r??{},s=this.workspaceChildren,a=this.getPath();if(!n.has(a)){n.add(a);for(let i of s){let c=i.resolveExport(t,{workspaceExportsVisited:n,...o})??i.resolveWorkspaceExport(t,{workspaceExportsVisited:n,...o});if(c!==void 0)return _(c)?[c,i]:c}}}resolveWorkspaceImport(t,r){let{workspaceImportsVisited:n=new Set,...o}=r??{},s=this.workspaceParents,a=this.getPath();if(!n.has(a)){n.add(a);for(let i of s){let c=i.resolveImport(t,{workspaceImportsVisited:n,...o})??i.resolveWorkspaceImport(t,{workspaceImportsVisited:n,...o});if(c!==void 0)return _(c)?[c,i]:c}}}};var lr=new Map,fe=class extends Xe{importMapSortedEntries;exportMapSortedEntries;getName(){return this.packageInfo.name??"@no-name/package"}getVersion(){return this.packageInfo.version??"0.0.0"}getPath(){let t=this.packagePath;return t||`${Mt}/${this.getName()}/${this.getVersion()}/deno.json`}constructor(t,r){super(t,r);let{exports:n={},imports:o={}}=t,s=_(n)?n.endsWith("/")?{"./":n}:{".":n}:n,a={...o};for(let[i,c]of j(a)){let p=N(i);i!==p&&!(p in a)&&(a[p]=N(c))}this.exportMapSortedEntries=j(s).toSorted(qe),this.importMapSortedEntries=j(a).toSorted(qe)}resolveExport(t,r){let n=this.getPath();if(r?.workspaceExportsVisited?.has(n))return;let o=this.getName(),s=this.getVersion(),{baseAliasDir:a,basePathDir:i=le(n).dirpath,...c}=r??{},p=a===void 0?[`jsr:${o}@${s}`,`jsr:${o}`,`${o}`]:[a];for(let u of p){let l=X(t,u)?.replace(/^\/+/,"/");l!==void 0&&(t=u+(l==="/"?"":l));let g=super.resolveExport(t,{baseAliasDir:u,basePathDir:i,...c});if(g)return g}}resolveImport(t,r){let n=this.getPath();if(r?.workspaceImportsVisited?.has(n))return;let o=le(n).dirpath,s=Me(t),a=s?"":void 0;return this.resolveExport(t,{...r,baseAliasDir:a})??super.resolveImport(t,{...r,basePathDir:o})}resolveWorkspaceImport(t,r){return this.resolveWorkspaceExport(t,r)??super.resolveWorkspaceImport(t,r)}static async fromUrl(t){let r=D(t,me()),n=r.href,o=n.startsWith("jsr:"),s=n.endsWith("/");if(o){let{host:g}=K(t);t=await An(`jsr:${g}`)}else if(s){let g=Ze.map(f=>new URL(f,r)),d=await Oe(g);if(!d)throw new Error(`Scan Error! failed to find a "./deno.json(c)" or "./jsr.json(c)" package file in your supplied directory: "${r}".`);t=d}let a=await super.fromUrl(t),i=a.getPath(),c=lr.get(i);if(c)return await c,a;let[p,u,l]=z();return lr.set(i,p),await it((a.packageInfo.workspace??[]).map(async g=>{let d=N(me(g,i));await a.addWorkspaceChild(d)})),u(),a}},Mt="https://jsr.io",Ze=["./deno.json","./deno.jsonc","./jsr.json","./jsr.jsonc"],On=async e=>{let{protocol:t,scope:r,pkg:n,pathname:o,version:s}=K(e);if(t!=="jsr:")throw new Error(`expected path protocol to be "jsr:", found "${t}" instead, for package: "${e}"`);if(!r)throw new Error(`expected jsr package to contain a scope, but found "${r}" instead, for package: "${e}"`);let a=new URL(`@${r}/${n}/meta.json`,Mt),i=await(await fetch(a,ue)).json(),c=j(i.versions).filter(([d,{yanked:f}])=>!f).map(([d])=>d),p=wt(c,s??i.latest);if(!p)throw new Error(`failed to find the desired version "${s}" of the jsr package "${e}", with available versions "${he(i.versions)}"`);let u=new URL(`@${r}/${n}/${p}/`,Mt),l=Ze.map(d=>new URL(d,u)),g=await Oe(l,{method:"HEAD"});if(g)return new URL(g);throw new Error(`Network Error: couldn't locate "${e}"'s package json file. searched in the following locations:
${he(l)}`)},An=Ct(On);var B=console.log,Dn=e=>{let t=xe(e);return(...r)=>{t(r)}},ur=[],Un=Dn(ur),dr=()=>{let e=ct();return(r,...n)=>{let o=e,[s,a]=z();return e=s,o.finally(()=>{a(r(...n))}),s}},mr=e=>(Ve(e)||(e=j(e)),e.map(t=>_(t)?[t,t]:Ve(t)?t:[t.in,t.out]));var Q=[void 0,"","file"],Ot=["base64","binary","copy","css","dataurl","default","empty","file","js","json","jsx","local-css","text","ts","tsx"],et=(r=>(r[r.CWD=0]="CWD",r[r.ABS_WORKING_DIR=1]="ABS_WORKING_DIR",r))(et||{});var Ln={filters:[/.*/],initialPluginData:void 0,forceInitialPluginData:!1,enableInheritPluginData:!0,scanAncestralWorkspaces:!1,acceptNamespaces:Q},gr="<stdin>",jn=e=>{let{filters:t,initialPluginData:r,forceInitialPluginData:n,enableInheritPluginData:o,scanAncestralWorkspaces:s,acceptNamespaces:a}={...Ln,...e},i=new Set([...a,"oazmi-loader-http"]),c=new Map,p=ie(c),u=ve(c),l=be(c),g=Symbol("[oazmi-entry]: already captured by initial-data-injector"),d=Symbol("[oazmi-entry]: already captured by inherit-data-injector"),f=Symbol("[oazmi-entry]: already captured by absolute-path-resolver");return async S=>{let{runtimePackage:$,...G}=r??{},O=G,L=r!==void 0;S.onStart(async()=>{O.runtimePackage=await Fn(S,$,s);let E=S.initialOptions.stdin;if(E){let{sourcefile:C=gr,resolveDir:k=""}=E,v=C===gr?C:k?ee(k,C):T(C);u(v,O)}});let w=async E=>{let{path:C,pluginData:k,...v}=E,{kind:h,namespace:R}=v;if(h!=="entry-point"||(k??{})[g]||!i.has(R)||k!==void 0&&!n)return;let y=n==="merge"?{...O,...k,[g]:!0}:{...O,[g]:!0},x=await S.resolve(C,{...v,pluginData:y});return x.pluginData??=y,x},M=async E=>{let{path:C,pluginData:k,...v}=E,{importer:h="",namespace:R}=v;if((k??{})[d]||!i.has(R))return;if(k==null&&h!==""){let m=p(T(h));return m?M({...v,path:C,pluginData:m}):void 0}let y={...k,[d]:!0},x=await S.resolve(C,{...v,pluginData:y}),I={...x.pluginData??y,[d]:!1};if(I.resolverConfig?.useInheritPluginData!==!1){let m=T(x.path);l(m)||u(T(x.path),I)}return x.pluginData=I,x},F=async E=>{if((E.pluginData??{})[f]||!i.has(E.namespace))return;let{path:C,namespace:k,...v}=E,h=await S.resolve(C,{...v,namespace:"oazmi-resolver-pipeline"}),{path:R,pluginData:y={},namespace:x}=h,I={...y,[f]:!0},m=await S.resolve(R,{...v,namespace:k,pluginData:I});return m.pluginData={...m.pluginData??I,[f]:!1},m};for(let E of t)L&&S.onResolve({filter:E},w),o&&S.onResolve({filter:E},M),S.onResolve({filter:E},F)}},Ut=e=>({name:"oazmi-entry",setup:jn(e)}),Fn=async(e,t,r=!0)=>{let n,o;if(t)return t instanceof Ae?n=t:(o=_(t)&&W(t)==="relative"?(await e.resolve(t,{kind:"entry-point",namespace:"oazmi-resolver-pipeline",pluginData:{resolverConfig:{useNodeModules:!1}}})).path:t,n=await fe.fromUrl(o).catch(a=>{B(`[resolveRuntimePackage]    : ${a?.message??a}`)})),r&&(n??o)&&await fr(n?.getPath()??o),n},fr=async e=>{let t=D("./",e),r=D("../",t);if(r.href===t.href)return;let n=Ze.map(s=>new URL(s,t)),o=await Oe(n);if(o){let s=await fe.fromUrl(o).catch(a=>{B(`[resolveRuntimePackage]    : workspace file at "${o}" was found, but we failed to load it as a deno package. reason:  ${a?.message??a}`)})}return fr(r)};var hr={base64:[],binary:[".bin",".dat"],copy:[],css:[".css"],dataurl:[],default:[],empty:[],file:[".jpg",".jpeg",".png",".gif",".svg",".webp",".bmp",".tiff",".ico",".mp4",".webm",".ogg",".avi",".mp3",".wav",".aac"],js:[".js",".mjs",".cjs"],json:[".json"],jsx:[".jsx"],"local-css":[".module.css"],text:[".txt",".html",".md",".xml",".csv"],ts:[".ts",".mts",".cts"],tsx:[".tsx"]};var _r={base64:["application/octet-stream","application/base64"],binary:["application/octet-stream","application/binary","application/x-binary","image/vnd.microsoft.icon"],copy:["application/octet-stream","application/x-copy"],css:["text/css"],dataurl:["application/data-url","text/data-url"],default:[],empty:[],file:["application/octet-stream","application/x-file","image/jpeg","image/png","image/gif","image/svg+xml","image/webp","image/bmp","image/tiff","image/vnd.microsoft.icon","video/mp4","video/webm","video/ogg","video/x-msvideo","audio/mpeg","audio/ogg","audio/wav","audio/x-aac","audio/webm"],js:["application/javascript","text/javascript","application/x-javascript","application/ecmascript","text/ecmascript"],json:["application/json","text/json"],jsx:["application/javascript","text/javascript","application/jsx"],"local-css":["text/css","text/x-css"],text:["text/plain","text/html","text/markdown","text/xml","text/csv"],ts:["application/typescript","text/typescript"],tsx:["application/typescript","text/typescript","application/tsx"]};var Kn=j(_r).map(([e,t])=>[e,new Set(t)]),$n=j(hr).map(([e,t])=>[e,new Set(t)]),Vn=new Pe(new Map(Kn)),Wn=new Pe(new Map($n)),Bn=e=>{let[t,...r]=e.split(";"),n=t.trim().toLowerCase();return Vn.rget(n)},Gn=e=>{let t=e.endsWith(".module.css")?".module.css":le(e).extname;return Wn.rget(t)},yr=e=>{let{headers:t,url:r}=e,n=t.get("content-type")??"",o=Bn(n)??new Set,s=Gn(r)??new Set,a=o.intersection(s);return a.size<=0&&(a=s),a.size<=0&&(a=o),a};var zn=e=>{let{defaultLoader:t,acceptLoaders:r=Ot,log:n=!1}=e,o=new Set(r),s=n?n===!0?B:n:void 0;return async a=>{let{path:i,pluginData:c}=a,p=D(i),u=await fetch(p,ue);if(!u.ok)throw new Error(`[urlLoaderFactory]: ERROR: network fetch response for url "${p.href}" was not ok (${u.status}). response header:
${he(u.headers)}`);let l=yr(u),g=o.intersection(l),d=[...g].at(0)??t,f=await u.bytes();return s&&s("[urlLoaderFactory]:",{path:i,path_url:p.href,guessed_loaders:l,preferred_loader:d,args:a}),{contents:f,loader:d,pluginData:c}}},xr={enabled:!0,resolveAgain:!0},Hn={filters:[/^https?\:\/\//,/^file\:\/\//],namespace:"oazmi-loader-http",acceptNamespaces:Q,defaultLoader:"copy",acceptLoaders:void 0,convertFileUriToLocalPath:xr,log:!1},Yn=(e={})=>{let{acceptLoaders:t,defaultLoader:r,filters:n,namespace:o,acceptNamespaces:s,log:a,convertFileUriToLocalPath:i}={...Hn,...e},c=new Set([...s,o]),p={acceptLoaders:t,defaultLoader:r,log:a},u={...xr,...i};return async l=>{let{absWorkingDir:g,outdir:d,outfile:f,entryPoints:S,write:$,loader:G}=l.initialOptions,O=async L=>{let{path:w,pluginData:M,namespace:F,...E}=L,C=F===o?"":F;if(c.has(F))return u.enabled&&W(w)==="file"?u.resolveAgain?l.resolve(we(w),{...E,pluginData:M,namespace:C}):{path:we(w),pluginData:M,namespace:C}:{path:w,pluginData:M,namespace:o}};n.forEach(L=>{l.onResolve({filter:L},O)}),l.onLoad({filter:/.*/,namespace:o},zn(p))}},Lt=e=>({name:"oazmi-http-plugin",setup:Yn(e)});var Jn={filters:[/^jsr\:/],acceptNamespaces:Q},qn=(e={})=>{let{filters:t,acceptNamespaces:r}={...Jn,...e},n=new Set([...r,"oazmi-loader-http"]);return async o=>{let{absWorkingDir:s,outdir:a,outfile:i,entryPoints:c,write:p,loader:u}=o.initialOptions,l=async g=>{if(!n.has(g.namespace))return;let{path:d,pluginData:f={},...S}=g,{importMap:$,runtimePackage:G,resolverConfig:O={},...L}=f,w=await fe.fromUrl(d),M=K(d).pathname,F=M==="/"?".":ce(M),E={baseAliasDir:""},C=w.resolveExport(F,E);if(!C)throw new Error(`failed to resolve the path "${d}" from the deno package: "jsr:${w.getName()}@${w.getVersion()}"`);return o.resolve(C,{...S,pluginData:{...L,runtimePackage:w,resolverConfig:{...O,useNodeModules:!1}}})};t.forEach(g=>{o.onResolve({filter:g},l)})}},jt=e=>({name:"oazmi-jsr-plugin",setup:qn(e)});var br={enabled:!0},vr={enabled:!0,globalImportMap:{}},Rr={enabled:!0},Pr={enabled:!0,resolvePath:me,isAbsolutePath:ne},Qn={runtimePackage:br,importMap:vr,nodeModules:Rr,relativePath:Pr,namespace:"oazmi-resolver-pipeline",log:!1},Xn=e=>{let{runtimePackage:t,importMap:r,nodeModules:n,relativePath:o,namespace:s,log:a}={...Qn,...e},i={...br,...t},c={...vr,...r},p={...Rr,...n},u={...Pr,...o},l=a?a===!0?B:a:void 0,g="discard-this-namespace",d=/.*/;return async f=>{let S=T(f.initialOptions.absWorkingDir??"./"),$=new Set(f.initialOptions.external),G=$.size<=0?ge:async v=>{let{path:h,pluginData:R={}}=v,y=$.has(h);return l&&l(`[external-path]    checking: ${h}`+(y?`
>> successfully verified the path to be external`:"")),y?{path:h,external:!0,namespace:g,pluginData:{...R}}:void 0},O=i.enabled===!1?ge:async v=>{if(v.pluginData?.resolverConfig?.useRuntimePackage===!1)return;let{path:h,pluginData:R={}}=v,y=R.runtimePackage,x=y&&!Me(h)?y.resolveImport(h)??y.resolveWorkspaceImport(h):void 0,[I,m]=Ie(x)?x:[x,y];return l&&l(`[runtime-package] resolving: ${h}`+(I?`
>> successfully resolved to: ${I}`:"")),I?{path:I,namespace:g,pluginData:{...R,runtimePackage:m}}:void 0},{globalImportMap:L}=c,w=c.enabled===!1?ge:async v=>{if(v.pluginData?.resolverConfig?.useImportMap===!1)return;let{path:h,pluginData:R={}}=v,y={...L,...R.importMap},x=cr(h,y);return l&&l(`[import-map]      resolving: ${h}`+(x?`
>> successfully resolved to: ${x}`:"")),x?{path:x,namespace:g,pluginData:{...R}}:void 0},{resolvePath:M,isAbsolutePath:F}=u,E=Kt({absWorkingDir:M(N(S))},f),C=p.enabled===!1?ge:async v=>{let{path:h,resolveDir:R,importer:y,pluginData:x={}}=v;if(x.resolverConfig?.useNodeModules===!1||x.resolverConfig?.useRelativePath!==!1&&(Me(h)||F(h)))return;let I=M(N(R||S)),m=T(h),b=E({importer:y,path:m,resolveDir:I}),{path:P,namespace:A,pluginData:Y,...V}=await b.catch(()=>({}));return l&&l(`[node-module]     resolving: ${h}`+(P?`
>> successfully resolved to: ${P}`:"")),P?{...V,path:P,namespace:g,pluginData:{...x}}:void 0},k=u.enabled===!1?ge:async v=>{if(v.pluginData?.resolverConfig?.useRelativePath===!1)return;let{path:h,importer:R,resolveDir:y,pluginData:x={}}=v,I=M(N(y||S)),m=F(R)?R:ee(I,R),b=M(h,m||void 0);return l&&l(`[absolute-path]   resolving: ${h}`+(b?`
>> successfully resolved to: ${b}`:"")),{path:b,namespace:g,pluginData:{...x}}};f.onResolve({filter:d,namespace:s},G),f.onResolve({filter:d,namespace:s},O),f.onResolve({filter:d,namespace:s},w),f.onResolve({filter:d,namespace:s},C),f.onResolve({filter:d,namespace:s},k)}},Ft=e=>({name:"oazmi-plugindata-resolvers",setup:Xn(e)}),Kt=(e,t)=>{let{absWorkingDir:r}=e,n=o=>s=>{let a=Symbol(),i="the-void",{resolve:c,reject:p,resolveDir:u,importer:l=""}=o,g=W(l),d=g==="local"||g==="file"?D("./",l).href:void 0,f=d??u;f===""&&B('[nodeModulesResolverFactory]: WARNING! received an empty resolve directory ("args.resolveDir").',`
	we will fallback to esbuild's current-working-directory for filling in the "resolveDir" value,`,`
	however, you must be using the "nodeModulesResolverFactory" function incorrectly to have encountered this situation.`,`
	remember, the purpose of this function is to scan for a node-module, starting from a directory that YOU provide.`),s.onResolve({filter:/.*/},async S=>{if(S.pluginData?.[a]===!0)return;let{path:$,external:G,namespace:O,sideEffects:L,suffix:w}=await s.resolve(Z(S.path),{kind:"entry-point",resolveDir:Z(f!==""?f:S.resolveDir),pluginData:{[a]:!0}});return c({path:T($),external:G,namespace:O,sideEffects:L,suffix:w}),{path:"does-not-matter.js",namespace:i}}),s.onLoad({filter:/.*/,namespace:i},()=>({contents:"",loader:"empty"}))};return async o=>{let{path:s,resolveDir:a="",importer:i}=o,c=a===""?r??"":a,[p,u,l]=z(),g={name:"native-esbuild-resolver-capture",setup:n({resolve:u,reject:l,resolveDir:c,importer:i})};return await t.esbuild.build({entryPoints:[s],absWorkingDir:r,bundle:!1,minify:!1,write:!1,outdir:"./temp/",plugins:[g]}).catch(()=>{l("esbuild's native resolver failed to resolve the path")}),p}};var Zn={dir:1,command:e=>`npm install "${e}" --no-save`},Sr=dr(),Er=new Map,q="npm:",eo={specifiers:[q],sideEffects:"auto",autoInstall:!0,peerDependencies:{},acceptNamespaces:Q,nodeModulesDirs:[1],log:!1},to=(e={})=>{let{specifiers:t,sideEffects:r,autoInstall:n,peerDependencies:o,acceptNamespaces:s,nodeModulesDirs:a,log:i}={...eo,...e},c=i?i===!0?B:i:void 0,p=new Set([...s,"oazmi-loader-http"]),u=_(r)?void 0:r,l=De(n),g=st(mr(o).map(([d,f])=>{let S=X(d,q,"")??d,{scope:$,pkg:G}=K(q+S),O=($?"@"+$+"/":"")+G,L=X(f,q,"")??f,{host:w}=K(q+L);return[O,q+w]}));return te(l)&&a.unshift(l.dir),(async d=>{let{absWorkingDir:f,outdir:S,outfile:$,entryPoints:G,write:O,loader:L}=d.initialOptions,w=N(de),M=f?N(T(f)):de,F=h=>{switch(h){case 0:return w;case 1:return M;default:return Tr(h)}},E=[...new Set(a.map(F))],C=ro(d),k=te(l)?{dir:F(l.dir),command:l.command,log:i}:l;k&&d.onStart(async()=>{let h=k==="dynamic",R=j(g);!oe(R)&&1&&c&&c("[npmPlugin] peer-dependency: the following peer dependencies were specified:",g);for(let[y,x]of R){let{host:I,version:m}=K(x),b=m===void 0?y===I:I.startsWith(y+"@"),P=`${y}@npm:${I}`,A=b||h?I:P;!b&&h&&(c??B)('[npmPlugin]: WARNING! auto peer dependency package installation under an aliased name is not possible with "autoInstall" set to "dynamic".',`
	this will very likely lead to a broken import. please set "autoInstall" to one of the cli options, such as "auto-cli".`,`
	warning generated for the peer dependency package: "${x}", with alias: "${y}".`),await Sr(Cr,A,k)}});let v=h=>(async R=>{if(!p.has(R.namespace))return;let{path:y,pluginData:x={},resolveDir:I="",namespace:m,...b}=R,P=X(y,h,q),{scope:A,pkg:Y,pathname:V,version:mo}=K(P),tt=(A?"@"+A+"/":"")+Y,Le=`${tt}${V==="/"?"":V}`,{importMap:go,runtimePackage:fo,resolverConfig:Ir,...kr}=x,Vt=I===""?E:[I,...E],rt=Er.get(tt),Wt;if(rt)await rt;else{let[wr,Nr]=z();Er.set(tt,rt=wr),Wt=Nr}let Ee=await C(Le,Vt);!Ee&&k&&(await Sr(Cr,P,k),Ee=await C(Le,Vt)),Ee||(c??B)(`[npmPlugin]: WARNING! no valid "resolveDir" directory was found to contain the npm package named "${Le}"`,`
	we will still continue with the path resolution (in case the global-import-map may alter the situation),`,`
	but it is almost guaranteed not to work if the current-working-directory was already part of the scanned directories.`),Wt?.();let Ce=await d.resolve(Le,{...b,resolveDir:Ee,namespace:"oazmi-resolver-pipeline",pluginData:{...kr,resolverConfig:{useRuntimePackage:!1,useImportMap:!1,useNodeModules:!0}}}),Bt=Ce.path;return c&&c(`[npmPlugin]       resolving: "${y}", with resolveDir: "${Ee}"`+(Bt?`
>> successfully resolved to: ${Bt}`:"")),u!==void 0&&(Ce.sideEffects=u),Ce.namespace="",Object.assign(Ce.pluginData.resolverConfig,{...Ir,useRuntimePackage:!1,useNodeModules:!0}),Ce});t.forEach(h=>{let R=new RegExp(`^${Re(h)}`);d.onResolve({filter:R},v(h))})})},$t=e=>({name:"oazmi-npm-plugin",setup:to(e)}),Tr=e=>{let t=_(e)?e:e.href,r=W(t),n=pe(N(r==="relative"?ee(N(de),t):t));switch(r){case"local":case"relative":case"file":return Z(n);default:throw new Error(`expected a filesystem path, or a "file://" url, but received the incompatible uri scheme "${r}".`)}},ro=e=>{let t=Kt({absWorkingDir:void 0},e),r=async(n,o)=>((await t({path:o,importer:"",resolveDir:n})).path??"")!=="";return async(n,o)=>{let s=o.map(Tr);for(let a of s)if(await r(a,n))return a}},Ue=Ne(),no=e=>`deno cache --node-modules-dir="auto" --allow-scripts --no-config "npm:${e}"`,oo=e=>`deno cache --node-modules-dir="auto" --no-config "npm:${e}"`,so=e=>`npm install "${e}" --no-save`,ao=e=>`bun install "${e}" --no-save`,io=e=>`pnpm install "${e}"`,De=e=>{if(e){if(te(e))return{...Zn,...e};switch(e){case"auto":return Ue===0||Ue===1?"dynamic":De("npm");case!0:case"auto-cli":switch(Ue){case 0:return De("deno");case 1:return De("bun");case 2:return De("npm");default:throw new Error("ERROR! cli-installation of npm-packages is not possible on web-browser runtimes.")}case"dynamic":return"dynamic";case"deno":return{dir:1,command:no};case"deno-noscript":return{dir:1,command:oo};case"bun":return{dir:1,command:ao};case"npm":return{dir:1,command:so};case"pnpm":return{dir:1,command:io};default:return}}},Cr=async(e,t)=>{switch(Ue){case 0:case 1:case 2:return t==="dynamic"?po(e):co(e,t);default:throw new Error("ERROR! npm-package installation is not possible on web-browser runtimes.")}},co=async(e,t)=>{let{command:r,dir:n,log:o}=t,s=o?o===!0?B:o:void 0,a=K(e.startsWith(q)?e:q+e),i=a.host,c=i.includes("@npm:"),p=r(c?e:i);s&&s(`[npmPlugin]      installing: "${e}", in directory "${n}"
>>    using the cli-command: \`${p}\``),await St(Ue,p,{cwd:n})},po=async e=>{let t=K(e.startsWith(q)?e:q+e),r=t.href.replace(/^npm\:[\/\\]*/,q).slice(0,t.pathname==="/"?-1:void 0),n=`export * as myLib from "${ye(r)}"`,o=new Blob([n],{type:"text/javascript"});await import(URL.createObjectURL(o))};var lo={initialPluginData:void 0,scanAncestralWorkspaces:!1,log:!1,logFor:["npm","resolver"],autoInstall:!0,peerDependencies:{},nodeModulesDirs:[1],globalImportMap:{},getCwd:de,acceptNamespaces:Q},uo=e=>{let{acceptNamespaces:t,autoInstall:r,getCwd:n,globalImportMap:o,log:s,logFor:a,peerDependencies:i,nodeModulesDirs:c,initialPluginData:p,scanAncestralWorkspaces:u}={...lo,...e},l=Nt(n,ne);return[Ut({initialPluginData:p,scanAncestralWorkspaces:u,acceptNamespaces:t}),Lt({acceptNamespaces:t,log:a.includes("http")?s:!1}),jt({acceptNamespaces:t}),$t({acceptNamespaces:t,autoInstall:r,peerDependencies:i,nodeModulesDirs:c,log:a.includes("npm")?s:!1}),Ft({log:a.includes("resolver")?s:!1,importMap:{globalImportMap:o},relativePath:{resolvePath:l}})]};export{et as DIRECTORY,Ot as allEsbuildLoaders,Un as arrayLogger,ur as arrayLoggerHistory,Q as defaultEsbuildNamespaces,uo as denoPlugins,Ut as entryPlugin,Lt as httpPlugin,jt as jsrPlugin,B as logLogger,$t as npmPlugin,Ft as resolverPlugin};
