function Jt(e,t,r){let o=r===void 0?t:t.bind(r),n=e.length-1;for(;n>=0;){if(o(e[n],n,e))return n;n--}return-1}function qt(e,t,r){let o=e.findLastIndex(t,r);return o===-1?void 0:e[o]}Array.prototype.findLastIndex||(Array.prototype.findLastIndex=function(e,t){return Jt(this,e,t)});Array.prototype.findLast||(Array.prototype.findLast=function(e,t){return qt(this,e,t)});Uint8Array.prototype.findLastIndex||(Uint8Array.prototype.findLastIndex=function(e,t){return Jt(this,e,t)});Uint8Array.prototype.findLast||(Uint8Array.prototype.findLast=function(e,t){return qt(this,e,t)});var Gr={},Qt=Hr(globalThis,Gr);function Hr(e,t){return new Proxy(e,{get(r,o,n){return o in t?t[o]:e[o]},set(r,o,n){return o in t&&delete t[o],e[o]=n,!0},deleteProperty(r,o){let n=!1;return o in t&&(delete t[o],n=!0),o in e&&(delete e[o],n=!0),n},ownKeys(r){let o=Reflect.ownKeys(e),n=Reflect.ownKeys(t),s=new Set(n);return[...o.filter(i=>!s.has(i)),...n]},defineProperty(r,o,n){return o in t&&delete t[o],Reflect.defineProperty(e,o,n),!0},getOwnPropertyDescriptor(r,o){return o in t?Reflect.getOwnPropertyDescriptor(t,o):Reflect.getOwnPropertyDescriptor(e,o)},has(r,o){return o in t||o in e}})}var Kr=Array;var Xr=JSON;var Fe=Object,Zt=Promise;var er=Symbol;var ue=e=>e.length===0;var tr=Kr.isArray;var be=Xr.stringify;var pt=Fe.assign;var z=Fe.entries;var lt=Fe.fromEntries;var ut=Fe.keys;var ne=()=>{let e,t;return[new Promise((o,n)=>{e=o,t=n}),e,t]};var Ue=Zt.resolve.bind(Zt);var mt=er.iterator;var rr=er.toStringTag;var We=encodeURI;var me=decodeURI;var $;(function(e){e[e.LOG=0]="LOG",e[e.ASSERT=0]="ASSERT",e[e.ERROR=1]="ERROR",e[e.PRODUCTION=1]="PRODUCTION",e[e.MINIFY=1]="MINIFY"})($||($={}));var Y=(e,t,...r)=>o=>e[t].bind(o,...r);var ze=(e,t,...r)=>e[t].bind(e,...r),dt=e=>e.prototype,Yr=dt(Array),ae=dt(Map),ft=dt(Set);var Oe=Y(Yr,"push");var ht=Y(ft,"add");var gt=Y(ft,"delete");var _t=Y(ft,"has");var xt=Y(ae,"delete"),yt=Y(ae,"entries"),bt=Y(ae,"forEach"),de=Y(ae,"get"),Pe=Y(ae,"has"),Pt=Y(ae,"keys"),Ee=Y(ae,"set"),Et=Y(ae,"values");var Be=e=>{let t=typeof e;return t==="object"||t==="function"};var se=e=>typeof e=="object",Ge=tr;var j=e=>typeof e=="string";var Zr=/[.*+?^${}()|[\]\\]/g,Rt=e=>e.replaceAll(Zr,"\\$&"),re=(e,t,r="")=>e.startsWith(t)?r+e.slice(t.length):void 0,He=(e,t,r="")=>e.endsWith(t)?(t===""?e:e.slice(0,-t.length))+r:void 0;var eo=z({"node:":"node","npm:":"npm","jsr:":"jsr","blob:":"blob","data:":"data","http://":"http","https://":"https","file://":"file","./":"relative","../":"relative"}),to=["blob","data","relative"],ro=["jsr","npm","node"],oo=["jsr:","npm:","node:"],J="/",Ve="./",vt="../",no=/\\/g,so=/^[a-z]\:[\/\\]/i,io=/^\/+/;var ao=/\/?[^\/]+$/,co=/^(?<basename>.+?)(?<ext>\.[^\.]+)?$/,po=/^(?<protocol>jsr:|npm:|node:)(\/*(@(?<scope>[^\/\s]+)\/)?(?<pkg>[^@\/\s]+)(@(?<version>[^\/\r\n\t\f\v]+))?)?(?<pathname>\/.*)?$/,fe=(e,t)=>e.startsWith(t),ar=(e,t)=>e.endsWith(t),wt=e=>fe(e,J)||fe(e,"~")||so.test(e),V=e=>{if(!(!e||e==="")){for(let[t,r]of eo)if(fe(e,t))return r;return wt(e)?"local":"relative"}},B=e=>{e=me(j(e)?e:e.href);let{protocol:t,scope:r,pkg:o,version:n,pathname:s}=po.exec(e)?.groups??{};if(t===void 0||o===void 0)throw new Error($.ERROR?"invalid package url format was provided: "+e:"");let i=r||void 0,a=n||void 0,c=s||J,p=`${i?"@"+i+J:""}${o}${a?"@"+a:""}`,d=We(`${t}/${p}${c}`);return{protocol:t,scope:i,pkg:o,version:a,pathname:c,host:p,href:d}},A=(e,t)=>{if(!j(e))return e;e=P(e);let r=t;if(j(t)){let s=V(t);if(to.includes(s))throw new Error($.ERROR?"the following base scheme (url-protocol) is not supported: "+s:"");r=A(t)}let o=V(e),n=ro.includes(o);if(o==="local")return new URL("file://"+We(e));if(n)return new URL(B(e).href);if(o==="relative"){let s=r?r.protocol:void 0;if(!oo.includes(s))return new URL(We(e),r);let{protocol:a,host:c,pathname:p}=B(r),d=new URL(e,"x:"+p).pathname;e=`${a}/${c}${d}`}return new URL(e)},lo=e=>e.replace(io,"");var he=e=>fe(e,Ve)?e:fe(e,J)?"."+e:Ve+e,T=e=>ar(e,J)?e:e+J;var cr=(e,t={})=>{let{keepRelative:r=!0}=se(t)?t:{},o=e.split(J),n=o.at(-1),s=[".."],i=r&&o[0]===".";o.length>=2&&(n==="."||n==="..")&&o.push("");for(let c of o)c===".."?s.at(-1)!==".."?s.pop():s.push(c):c!=="."&&s.push(c);return s.shift(),i&&s[0]!==".."&&s.unshift("."),s.join(J)},ie=(e,t)=>cr(P(e),t),P=e=>e.replaceAll(no,J);var ir=e=>lo(ao.exec(e)?.[0]??""),uo=e=>{let{basename:t="",ext:r=""}=co.exec(e)?.groups??{};return[t,r]},St=e=>{let t=ie(e),r=ir(t),o=r.length,n=o>0?t.slice(0,-o):t,s=ir(n.slice(0,-1)),[i,a]=uo(r);return{path:t,dirpath:n,dirname:s,filename:r,basename:i,extname:a}};var pr=(...e)=>{e=e.map(r=>r==="."?Ve:r===".."?vt:r);let t=e.reduce((r,o)=>{let n=r.pop(),s=ar(n,J),i=s?n:n+J;if(!s){let a=fe(o,Ve),c=fe(o,vt);a?o="."+o:c&&(o=vt+o)}return r.push(i,o),r},[J]);return t.shift(),cr(t.join(""))},ce=(...e)=>pr(...e.map(P)),mo=(e,t=wt)=>{let r=j(e)?()=>e:e;return(...o)=>{let n=o.findLastIndex(t);return n>=0?o=o.slice(n):o.unshift(T(r())),pr(...o)}},ke=(e,t=wt)=>{j(e)&&(e=P(e));let r=j(e)?()=>e:()=>P(e()),o=mo(r,t);return(...n)=>o(...n.map(P))};var m;(function(e){e[e.DENO=0]="DENO",e[e.BUN=1]="BUN",e[e.NODE=2]="NODE",e[e.CHROMIUM=3]="CHROMIUM",e[e.EXTENSION=4]="EXTENSION",e[e.WEB=5]="WEB",e[e.WORKER=6]="WORKER"})(m||(m={}));var F=Qt,fo={[m.DENO]:()=>!!F.Deno?.version,[m.BUN]:()=>!!F.Bun?.version,[m.NODE]:()=>!!F.process?.versions,[m.CHROMIUM]:()=>!!F.chrome?.runtime,[m.EXTENSION]:()=>!!F.browser?.runtime,[m.WEB]:()=>!!F.window?.document,[m.WORKER]:()=>!!(se(F.self)&&Be(F.WorkerGlobalScope)&&F.self instanceof F.WorkerGlobalScope)},ho=[m.DENO,m.BUN,m.NODE,m.CHROMIUM,m.EXTENSION,m.WEB,m.WORKER],je=()=>{for(let e of ho)if(fo[e]())return e;throw new Error($.ERROR?`failed to detect current javascript runtime!
please report this issue to "https://github.com/omar-azmi/kitchensink_ts/issues", along with information on your runtime environment.`:"")},lr=e=>{switch(e){case m.DENO:return F.Deno;case m.BUN:return F.Bun;case m.NODE:return F.process;case m.CHROMIUM:return F.chrome;case m.EXTENSION:return F.browser;case m.WEB:return F.window;case m.WORKER:return F.self;default:throw new Error($.ERROR?`an invalid runtime enum was provided: "${e}".`:"")}},ur=(e,t=!0)=>{let r=lr(e);if(!r)throw new Error($.ERROR?`the requested runtime associated with the enum "${e}" is undefined (i.e. you're running on a different runtime from the provided enum).`:"");switch(e){case m.DENO:case m.BUN:case m.NODE:return P(r.cwd());case m.CHROMIUM:case m.EXTENSION:return r.runtime.getURL("");case m.WEB:case m.WORKER:return new URL("./",t?r.location.href:r.location.origin).href}};var go={args:[]},Ct=async(e,t,r={})=>{let{args:o,cwd:n,signal:s}={...go,...r},i=ue(o);if(!lr(e))throw new Error($.ERROR?`the requested runtime associated with the enum "${e}" is undefined (i.e. you're running on a different runtime from the provided enum).`:"");if(!t&&i)return{stdout:"",stderr:""};switch(e){case m.DENO:case m.BUN:case m.NODE:{let{exec:c}=await yo(),p=i?t:`${t} ${o.join(" ")}`,[d,l,_]=ne();return c(p,{cwd:n,signal:s},(f,u,k)=>{f&&_(f.message),l({stdout:u,stderr:k})}),d}default:throw new Error($.ERROR?`your non-system runtime environment enum ("${e}") does not support shell commands`:"")}};var _o;var xo=async()=>import("node:child_process"),yo=async()=>_o??=await xo();var It=e=>{let t=[];e.forEach(n=>{t.push(...n)});let r=new Map([...new Set(t)].map(n=>[n,new Set])),o=de(r);for(let[n,s]of e)s.forEach(i=>o(i).add(n));return r},Re=class{constructor(t,r){let o=t??(r?It(r):new Map),n=r??(t?It(t):new Map),s=Ee(o),i=Ee(n),a=xt(o),c=xt(n),p=o.size,d=n.size,l=bt(o),_=bt(n),f=de(o),u=de(n),k=Pe(o),G=Pe(n),U=yt(o),M=yt(n),v=Pt(o),E=Pt(n),H=Et(o),C=Et(n),D=(h,...w)=>{let S=f(h)??(s(h,new Set)&&f(h)),L=_t(S),ee=ht(S);for(let X of w)L(X)||(ee(X),u(X)?.add(h)||i(X,new Set([h])))},y=(h,...w)=>{let S=u(h)??(i(h,new Set)&&u(h)),L=_t(S),ee=ht(S);for(let X of w)L(X)||(ee(X),f(X)?.add(h)||s(X,new Set([h])))},g=()=>{o.clear(),n.clear()},I=(h,w=!1)=>{let S=f(h);if(S){for(let L of S)u(L).delete(h);w?S.clear():w=a(h)}return w},b=(h,w=!1)=>{let S=u(h);if(S){for(let L of S)f(L).delete(h);w?S.clear():w=c(h)}return w};pt(this,{fmap:o,rmap:n,size:p,rsize:d,forEach:l,rforEach:_,get:f,rget:u,has:k,rhas:G,entries:U,rentries:M,keys:v,rkeys:E,values:H,rvalues:C,add:D,radd:y,clear:g,delete:I,rdelete:b,remove:(h,...w)=>{let S=f(h);if(S){let L=gt(S);for(let ee of w)L(ee)&&u(ee).delete(h)}},rremove:(h,...w)=>{let S=u(h);if(S){let L=gt(S);for(let ee of w)L(ee)&&f(ee).delete(h)}},set:(h,w)=>(I(h,!0),D(h,...w),this),rset:(h,w)=>(b(h,!0),y(h,...w),this),[mt]:U,[rr]:"InvertibleMap"})}};var Ke=class{wmap=new WeakMap;smap=new Map;pick(t){return Be(t)?this.wmap:this.smap}get(t){return this.pick(t).get(t)}set(t,r){return this.pick(t).set(t,r),this}has(t){return this.pick(t).has(t)}delete(t){return this.pick(t).delete(t)}},bo=Symbol($.MINIFY||"represents an unset value for a tree");var oi=Symbol($.MINIFY||"a rejection by a throttled function"),ni=Symbol($.MINIFY||"a timeout by an awaited promiseTimeout function");var Po=(e,t=!1)=>{let r=t?new Ke:new Map,o=ze(r,"get"),n=ze(r,"set"),s=ze(r,"has");return{fn:a=>{let c=s(a),p=c?o(a):e(a);return c||n(a,p),p},memory:r}},Nt=e=>Po(e).fn;function kt(e){if(new.target)throw new TypeError("Cannot create an instance: parse is not a constructor");return new Ot(e).parse()}var Ot=class{#s=new Set(` 	\r
`);#a=new Set([..."[]{}:,/",...this.#s]);#e;#r;#o;constructor(t){this.#e=`${t}`,this.#r=this.#e.length,this.#o=this.#c()}parse(){let t=this.#t(),r=this.#n(t),{done:o,value:n}=this.#o.next();if(!o)throw new SyntaxError(pe(n));return r}#t(){let{done:t,value:r}=this.#o.next();if(t)throw new SyntaxError("Cannot parse JSONC: unexpected end of JSONC input");return r}*#c(){for(let t=0;t<this.#r;t++)if(!this.#s.has(this.#e[t])){if(this.#e[t]==="/"&&this.#e[t+1]==="*"){t+=2;let r=!1;for(;t<this.#r;t++)if(this.#e[t]==="*"&&this.#e[t+1]==="/"){r=!0;break}if(!r)throw new SyntaxError("Cannot parse JSONC: unexpected end of JSONC input");t++;continue}if(this.#e[t]==="/"&&this.#e[t+1]==="/"){for(t+=2;t<this.#r&&!(this.#e[t]===`
`||this.#e[t]==="\r");t++);continue}switch(this.#e[t]){case"{":yield{type:"BeginObject",position:t};break;case"}":yield{type:"EndObject",position:t};break;case"[":yield{type:"BeginArray",position:t};break;case"]":yield{type:"EndArray",position:t};break;case":":yield{type:"NameSeparator",position:t};break;case",":yield{type:"ValueSeparator",position:t};break;case'"':{let r=t,o=!1;for(t++;t<this.#r&&!(this.#e[t]==='"'&&!o);t++)o=this.#e[t]==="\\"&&!o;yield{type:"String",sourceText:this.#e.substring(r,t+1),position:r};break}default:{let r=t;for(;t<this.#r&&!this.#a.has(this.#e[t]);t++);t--,yield{type:"NullOrTrueOrFalseOrNumber",sourceText:this.#e.substring(r,t+1),position:r}}}}}#n(t){switch(t.type){case"BeginObject":return this.#p();case"BeginArray":return this.#l();case"NullOrTrueOrFalseOrNumber":return this.#u(t);case"String":return this.#i(t);default:throw new SyntaxError(pe(t))}}#p(){let t={};for(;;){let r=this.#t();if(r.type==="EndObject")return t;if(r.type!=="String")throw new SyntaxError(pe(r));let o=this.#i(r),n=this.#t();if(n.type!=="NameSeparator")throw new SyntaxError(pe(n));let s=this.#t();Object.defineProperty(t,o,{value:this.#n(s),writable:!0,enumerable:!0,configurable:!0});let i=this.#t();if(i.type==="EndObject")return t;if(i.type!=="ValueSeparator")throw new SyntaxError(pe(i))}}#l(){let t=[];for(;;){let r=this.#t();if(r.type==="EndArray")return t;t.push(this.#n(r));let o=this.#t();if(o.type==="EndArray")return t;if(o.type!=="ValueSeparator")throw new SyntaxError(pe(o))}}#i(t){let r;try{r=JSON.parse(t.sourceText)}catch{throw new SyntaxError(pe(t))}if(typeof r!="string")throw new TypeError(`Parsed value is not a string: ${r}`);return r}#u(t){if(t.sourceText==="null")return null;if(t.sourceText==="true")return!0;if(t.sourceText==="false")return!1;let r;try{r=JSON.parse(t.sourceText)}catch{throw new SyntaxError(pe(t))}if(typeof r!="number")throw new TypeError(`Parsed value is not a number: ${r}`);return r}};function pe({type:e,sourceText:t,position:r}){let o="";switch(e){case"BeginObject":o="{";break;case"EndObject":o="}";break;case"BeginArray":o="[";break;case"EndArray":o="]";break;case"NameSeparator":o=":";break;case"ValueSeparator":o=",";break;case"NullOrTrueOrFalseOrNumber":case"String":o=30<t.length?`${t.slice(0,30)}...`:t;break}return`Cannot parse JSONC: unexpected token "${o}" in JSONC at position ${r}`}function Xe(e,t){if(isNaN(e)||isNaN(t))throw new Error("Cannot compare against non-numbers");return e===t?0:e<t?-1:1}function fr(e=[],t=[]){return e.length&&!t.length?-1:!e.length&&t.length?1:0}function Dt(e=[],t=[]){let r=Math.max(e.length,t.length);for(let o=0;o<r;o++){let n=e[o],s=t[o];if(n===void 0&&s===void 0)return 0;if(s===void 0)return 1;if(n===void 0)return-1;if(typeof n=="string"&&typeof s=="number")return 1;if(typeof n=="number"&&typeof s=="string"||n<s)return-1;if(n>s)return 1}return 0}var ve="0|[1-9]\\d*",Eo="\\d*[a-zA-Z-][a-zA-Z0-9-]*",Ro=`(?<major>${ve})\\.(?<minor>${ve})\\.(?<patch>${ve})`,mr=`(?:${ve}|${Eo})`,hr=`(?:-(?<prerelease>${mr}(?:\\.${mr})*))`,dr="[0-9A-Za-z-]+",gr=`(?:\\+(?<buildmetadata>${dr}(?:\\.${dr})*))`,_r=`v?${Ro}${hr}?${gr}?`,xr=new RegExp(`^${_r}$`),yr="(?:<|>)?=?",vo="x|X|\\*",jt=`${ve}|${vo}`,Ye=`[v=\\s]*(?<major>${jt})(?:\\.(?<minor>${jt})(?:\\.(?<patch>${jt})${hr}?${gr}?)?)?`,br=new RegExp(`^(?<operator>~>?|\\^|${yr})\\s*${Ye}$`),Pr=new RegExp(`^(?<operator>${yr})\\s*(${_r})$|^$`);function At(e){return typeof e=="number"&&!Number.isNaN(e)&&(!Number.isFinite(e)||0<=e&&e<=Number.MAX_SAFE_INTEGER)}var Lt=256;var wo=new RegExp(`^${ve}$`);function K(e){return e.split(".").filter(Boolean).map(t=>{if(wo.test(t)){let r=Number(t);if(At(r))return r}return t})}function oe(e){return e.split(".").filter(Boolean)}function le(e,t){let r=Number(e);if(!At(r))throw new TypeError(t);return r}function ge(e){return Number.isNaN(e.major)&&Number.isNaN(e.minor)&&Number.isNaN(e.patch)&&(e.prerelease===void 0||e.prerelease.length===0)&&(e.build===void 0||e.build.length===0)}function q(e,t){return e===t?0:Xe(e.major,t.major)||Xe(e.minor,t.minor)||Xe(e.patch,t.patch)||fr(e.prerelease,t.prerelease)||Dt(e.prerelease,t.prerelease)}function Tt(e){return e.toFixed(0)}function Je(e){let t=Tt(e.major),r=Tt(e.minor),o=Tt(e.patch),n=e.prerelease?.join(".")??"",s=e.build?.join(".")??"";return[[`${t}.${r}.${o}`,n].filter(c=>c).join("-"),s].filter(c=>c).join("+")}function So(e,t){if(ge(t))return!0;let r=q(e,t);switch(t.operator){case"=":case void 0:return r===0;case"!=":return r!==0;case">":return r>0;case"<":return r<0;case">=":return r>=0;case"<=":return r<=0}}function qe(e,t){for(let r of t)if(!So(e,r))return!1;if(e.prerelease&&e.prerelease.length>0){for(let r of t){if(ge(r))continue;let{major:o,minor:n,patch:s,prerelease:i}=r;if(i&&i.length>0&&e.major===o&&e.minor===n&&e.patch===s)return!0}return!1}return!0}function Qe(e,t){return t.some(r=>qe(e,r))}var Ze={major:Number.NaN,minor:Number.NaN,patch:Number.NaN,prerelease:[],build:[]},we={operator:void 0,...Ze};function Er(e,t){return q(e,t)>0}function Mt(e,t){let r;for(let o of e)Qe(o,t)&&(r=r&&Er(r,o)?r:o);return r}function Co(e){let r=e.match(Pr)?.groups;if(!r)return null;let{operator:o,prerelease:n,buildmetadata:s}=r,i=r.major?{major:le(r.major,`Cannot parse comparator ${e}: invalid major version`),minor:le(r.minor,`Cannot parse comparator ${e}: invalid minor version`),patch:le(r.patch,`Cannot parse comparator ${e}: invalid patch version`),prerelease:n?K(n):[],build:s?oe(s):[]}:Ze;return{operator:o||void 0,...i}}function R(e){return!e||e.toLowerCase()==="x"||e==="*"}function Io(e){if(!R(e.major))return R(e.minor)?{operator:">=",major:+e.major,minor:0,patch:0,prerelease:[],build:[]}:R(e.patch)?{operator:">=",major:+e.major,minor:+e.minor,patch:0,prerelease:[],build:[]}:{operator:">=",major:+e.major,minor:+e.minor,patch:+e.patch,prerelease:e.prerelease?K(e.prerelease):[],build:[]}}function No(e){if(!R(e.major))return R(e.minor)?{operator:"<",major:+e.major+1,minor:0,patch:0,prerelease:[],build:[]}:R(e.patch)?{operator:"<",major:+e.major,minor:+e.minor+1,patch:0,prerelease:[],build:[]}:e.prerelease?{operator:"<=",major:+e.major,minor:+e.minor,patch:+e.patch,prerelease:K(e.prerelease),build:[]}:{operator:"<=",major:+e.major,minor:+e.minor,patch:+e.patch,prerelease:[],build:[]}}function Oo(e){let t=e.match(new RegExp(`^${Ye}`)),r=t?.groups;if(!r)return null;let o=t[0].length,n=e.slice(o).match(/^\s+-\s+/);if(!n)return null;let s=n[0].length,a=e.slice(o+s).match(new RegExp(`^${Ye}\\s*$`))?.groups;if(!a)return null;let c=Io(r),p=No(a);return[c,p].filter(Boolean)}function ko(e){let t=R(e.major),r=R(e.minor),o=R(e.patch),n=+e.major,s=+e.minor,i=+e.patch;if(t)return[we];if(r)return[{operator:">=",major:n,minor:0,patch:0},{operator:"<",major:n+1,minor:0,patch:0}];if(o)return n===0?[{operator:">=",major:n,minor:s,patch:0},{operator:"<",major:n,minor:s+1,patch:0}]:[{operator:">=",major:n,minor:s,patch:0},{operator:"<",major:n+1,minor:0,patch:0}];let a=K(e.prerelease??"");return n===0?s===0?[{operator:">=",major:n,minor:s,patch:i,prerelease:a},{operator:"<",major:n,minor:s,patch:i+1}]:[{operator:">=",major:n,minor:s,patch:i,prerelease:a},{operator:"<",major:n,minor:s+1,patch:0}]:[{operator:">=",major:n,minor:s,patch:i,prerelease:a},{operator:"<",major:n+1,minor:0,patch:0}]}function jo(e){let t=R(e.major),r=R(e.minor),o=R(e.patch),n=+e.major,s=+e.minor,i=+e.patch;if(t)return[we];if(r)return[{operator:">=",major:n,minor:0,patch:0},{operator:"<",major:n+1,minor:0,patch:0}];if(o)return[{operator:">=",major:n,minor:s,patch:0},{operator:"<",major:n,minor:s+1,patch:0}];let a=K(e.prerelease??"");return[{operator:">=",major:n,minor:s,patch:i,prerelease:a},{operator:"<",major:n,minor:s+1,patch:0}]}function Do(e){let t=R(e.major),r=R(e.minor),o=R(e.patch),n=+e.major,s=+e.minor,i=+e.patch;if(t)return[{operator:"<",major:0,minor:0,patch:0}];if(r)return o?[{operator:"<",major:n,minor:0,patch:0}]:[{operator:"<",major:n,minor:0,patch:0}];if(o)return[{operator:"<",major:n,minor:s,patch:0}];let a=K(e.prerelease??""),c=oe(e.build??"");return[{operator:"<",major:n,minor:s,patch:i,prerelease:a,build:c}]}function Ao(e){let t=R(e.minor),r=R(e.patch),o=+e.major,n=+e.minor,s=+e.patch;if(t)return r?[{operator:"<",major:o+1,minor:0,patch:0}]:[{operator:"<",major:o,minor:n+1,patch:0}];if(r)return[{operator:"<",major:o,minor:n+1,patch:0}];let i=K(e.prerelease??""),a=oe(e.build??"");return[{operator:"<=",major:o,minor:n,patch:s,prerelease:i,build:a}]}function Lo(e){let t=R(e.major),r=R(e.minor),o=R(e.patch),n=+e.major,s=+e.minor,i=+e.patch;if(t)return[{operator:"<",major:0,minor:0,patch:0}];if(r)return[{operator:">=",major:n+1,minor:0,patch:0}];if(o)return[{operator:">=",major:n,minor:s+1,patch:0}];let a=K(e.prerelease??""),c=oe(e.build??"");return[{operator:">",major:n,minor:s,patch:i,prerelease:a,build:c}]}function To(e){let t=R(e.major),r=R(e.minor),o=R(e.patch),n=+e.major,s=+e.minor,i=+e.patch;if(t)return[we];if(r)return o?[{operator:">=",major:n,minor:0,patch:0}]:[{operator:">=",major:n,minor:0,patch:0}];if(o)return[{operator:">=",major:n,minor:s,patch:0}];let a=K(e.prerelease??""),c=oe(e.build??"");return[{operator:">=",major:n,minor:s,patch:i,prerelease:a,build:c}]}function Mo(e){let t=R(e.major),r=R(e.minor),o=R(e.patch),n=+e.major,s=+e.minor,i=+e.patch;if(t)return[we];if(r)return[{operator:">=",major:n,minor:0,patch:0},{operator:"<",major:n+1,minor:0,patch:0}];if(o)return[{operator:">=",major:n,minor:s,patch:0},{operator:"<",major:n,minor:s+1,patch:0}];let a=K(e.prerelease??""),c=oe(e.build??"");return[{operator:void 0,major:n,minor:s,patch:i,prerelease:a,build:c}]}function $o(e){let t=e.match(br)?.groups;if(!t)return Co(e);switch(t.operator){case"^":return ko(t);case"~":case"~>":return jo(t);case"<":return Do(t);case"<=":return Ao(t);case">":return Lo(t);case">=":return To(t);case"=":case"":return Mo(t);default:throw new Error(`Cannot parse version range: '${t.operator}' is not a valid operator`)}}function Fo(e){return e.split(/\s+/).flatMap($o)}function et(e){let t=e.replaceAll(/(?<=<|>|=|~|\^)(\s+)/g,"").split(/\s*\|\|\s*/).map(r=>Oo(r)||Fo(r));if(t.some(r=>r.includes(null)))throw new TypeError(`Cannot parse version range: range "${e}" is invalid`);return t}function De(e){if(typeof e!="string")throw new TypeError(`Cannot parse version as version must be a string: received ${typeof e}`);if(e.length>Lt)throw new TypeError(`Cannot parse version as version length is too long: length is ${e.length}, max length is ${Lt}`);e=e.trim();let t=e.match(xr)?.groups;if(!t)throw new TypeError(`Cannot parse version: ${e}`);let r=le(t.major,`Cannot parse version ${e}: invalid major version`),o=le(t.minor,`Cannot parse version ${e}: invalid minor version`),n=le(t.patch,`Cannot parse version ${e}: invalid patch version`),s=t.prerelease?K(t.prerelease):[],i=t.buildmetadata?oe(t.buildmetadata):[];return{major:r,minor:o,patch:n,prerelease:s,build:i}}var _e=e=>(V(e)??"relative")!=="relative",xe={redirect:"follow",cache:"force-cache"},ye=T(P(ur(je(),!0))),tt=ke(ye,_e),Ae=()=>{};var Rr=(e,t)=>{e=ie(e);let r=t[e];if(r)return r;let o=ut(t).filter(n=>n.endsWith("/")).toSorted((n,s)=>s.length-n.length);for(let n of o)if(e.startsWith(n)){let s=t[n];if(!s.endsWith("/"))throw new Error(`the value ("${s}") of the matched import-map key ("${n}") for the path alias "${e}" MUST end with a trailing slash ("/") to be specification compliant.`);return e.replace(n,s)}},rt=([e,t],[r,o])=>r.length-e.length,Uo={baseAliasDir:"",basePathDir:"",sort:!0,errorCheck:!0},ot=(e,t,r)=>{let{baseAliasDir:o,basePathDir:n,errorCheck:s,sort:i}={...Uo,...r};o=He(o,"/")??o,n=He(n,"/")??n;let a=re(ie(e),o),c=a===""||o!==""&&a?.startsWith("/")?"."+a:a;if(c===void 0)return ot(e,t,{baseAliasDir:"",basePathDir:n,errorCheck:s,sort:i});i&&(t=t.toSorted(rt));for(let[p,d]of t){let l=re(c,p);if(l!==void 0){if(s&&p.endsWith("/")&&!d.endsWith("/"))throw new Error(`the value ("${d}") of the matched import-map key ("${p}") for the path alias "${e}" MUST end with a trailing slash ("/") to be specification compliant.`);let _=n===""||_e(d)?d:ce(T(n),d);if(l==="")return _;if(p.endsWith("/"))return ce(_,he(l))}}};var Se=class{packagePath;packageInfo;constructor(t,r){this.packageInfo=t,this.packagePath=r}getPath(){return this.packagePath}resolveExport(t,r){return ot(t,this.exportMapSortedEntries,{sort:!1,...r})}resolveImport(t,r){return ot(t,this.importMapSortedEntries,{sort:!1,...r})}static async fromUrl(t){t=A(t,tt());let r=kt(await(await fetch(t,xe)).text());return new this(r,t.href)}};var vr=e=>ie(e.endsWith("/")?e:e+"/../"),Ce=class extends Se{importMapSortedEntries;exportMapSortedEntries;getName(){return this.packageInfo.name}getVersion(){return this.packageInfo.version}getPath(){let t=this.packagePath;return t||`${$t}/${this.getName()}/${this.getVersion()}/deno.json`}constructor(t,r){super(t,r);let{exports:o={},imports:n={}}=t,s=j(o)?o.endsWith("/")?{"./":o}:{".":o}:o,i={...n};for(let[a,c]of z(i)){let p=T(a);a!==p&&!(p in i)&&(i[p]=T(c))}this.exportMapSortedEntries=z(s).toSorted(rt),this.importMapSortedEntries=z(i).toSorted(rt)}resolveExport(t,r){let o=this.getName(),n=this.getVersion(),s=P(this.getPath()),{baseAliasDir:i=`jsr:${o}@${n}`,basePathDir:a=vr(s),...c}=r??{},p=re(t,i)?.replace(/^\/+/,"/");return p!==void 0&&(t=i+(p==="/"?"":p)),super.resolveExport(t,{baseAliasDir:i,basePathDir:a,...c})}resolveImport(t,r){let o=this.getName(),n=this.getVersion(),s=P(this.getPath()),i=vr(s),a=t.startsWith("./")||t.startsWith("../"),c=a?[""]:[`jsr:${o}@${n}`,`jsr:${o}`,`${o}`],p;for(let d of c)if(p=this.resolveExport(t,{...r,baseAliasDir:d}),p)break;return p??super.resolveImport(t,{...r,basePathDir:i})}static async fromUrl(t){if((j(t)?t:t.href).startsWith("jsr:")){let{host:n}=B(t);t=await zo(`jsr:${n}`)}return super.fromUrl(t)}},$t="https://jsr.io",Wo=async e=>{let{protocol:t,scope:r,pkg:o,pathname:n,version:s}=B(e);if(t!=="jsr:")throw new Error(`expected path protocol to be "jsr:", found "${t}" instead, for package: "${e}"`);if(!r)throw new Error(`expected jsr package to contain a scope, but found "${r}" instead, for package: "${e}"`);let i=A(`@${r}/${o}/meta.json`,$t),a=await(await fetch(i,xe)).json(),c=z(a.versions).filter(([v,{yanked:E}])=>!E).map(([v])=>De(v)),p=Mt(c,et(s??a.latest));if(!p)throw new Error(`failed to find the desired version "${s}" of the jsr package "${e}", with available versions "${be(a.versions)}"`);let d=Je(p),l=A(`@${r}/${o}/${d}/`,$t),_=A("./deno.json",l),f=A("./deno.jsonc",l),u=A("./jsr.json",l),k=A("./jsr.jsonc",l),G=A("./package.json",l),U=A("./package.jsonc",l),M=[_,f,u,k];for(let v of M)if((await fetch(v,{...xe,method:"HEAD"})).ok)return v;throw new Error(`Network Error: couldn't locate "${e}"'s package json file. searched in the following locations:
${be(M)}`)},zo=Nt(Wo);var te=[void 0,"","file"],Ft=["base64","binary","copy","css","dataurl","default","empty","file","js","json","jsx","local-css","text","ts","tsx"],nt=(r=>(r[r.CWD=0]="CWD",r[r.ABS_WORKING_DIR=1]="ABS_WORKING_DIR",r))(nt||{});var Bo={filters:[/.*/],initialPluginData:void 0,forceInitialPluginData:!1,enableInheritPluginData:!0,acceptNamespaces:te},Go=e=>{let{filters:t,initialPluginData:r,forceInitialPluginData:o,enableInheritPluginData:n,acceptNamespaces:s}={...Bo,...e},i=new Set([...s,"oazmi-loader-http"]),a=new Map,c=de(a),p=Ee(a),d=Pe(a),l=Symbol("[oazmi-entry]: already captured by initial-data-injector"),_=Symbol("[oazmi-entry]: already captured by inherit-data-injector"),f=Symbol("[oazmi-entry]: already captured by absolute-path-resolver");return async u=>{let{runtimePackage:k,...G}=r??{},U=G,M=r!==void 0;u.onStart(async()=>{U.runtimePackage=await Ho(u,k)});let v=async C=>{let{path:D,pluginData:y,...g}=C,{kind:I,namespace:b}=g;if(I!=="entry-point"||(y??{})[l]||!i.has(b)||y!==void 0&&!o)return;let x=o==="merge"?{...U,...y,[l]:!0}:{...U,[l]:!0},O=await u.resolve(D,{...g,pluginData:x});return O.pluginData??=x,O},E=async C=>{let{path:D,pluginData:y,...g}=C,{importer:I="",namespace:b}=g;if((y??{})[_]||!i.has(b))return;if(y==null&&I!==""){let N=c(P(I));return N?E({...g,path:D,pluginData:N}):void 0}let x={...y,[_]:!0},O=await u.resolve(D,{...g,pluginData:x}),W={...O.pluginData??x,[_]:!1};if(W.resolverConfig?.useInheritPluginData!==!1){let N=P(O.path);d(N)||p(P(O.path),W)}return O.pluginData=W,O},H=async C=>{if((C.pluginData??{})[f]||!i.has(C.namespace))return;let{path:D,namespace:y,...g}=C,I=await u.resolve(D,{...g,namespace:"oazmi-resolver-pipeline"}),{path:b,pluginData:x={},namespace:O}=I,W={...x,[f]:!0},N=await u.resolve(b,{...g,namespace:y,pluginData:W});return N.pluginData={...N.pluginData??W,[f]:!1},N};for(let C of t)M&&u.onResolve({filter:C},v),n&&u.onResolve({filter:C},E),u.onResolve({filter:C},H)}},Wt=e=>({name:"oazmi-entry",setup:Go(e)}),Ho=async(e,t)=>{let r=t!==void 0,o=t instanceof Se,n=!r||o?void 0:j(t)?A((await e.resolve(t,{kind:"entry-point",namespace:"oazmi-resolver-pipeline",pluginData:{resolverConfig:{useNodeModules:!1}}})).path):t;return r?o?t:await Ce.fromUrl(n):void 0};var wr={base64:[],binary:[".bin",".dat"],copy:[],css:[".css"],dataurl:[],default:[],empty:[],file:[".jpg",".jpeg",".png",".gif",".svg",".webp",".bmp",".tiff",".ico",".mp4",".webm",".ogg",".avi",".mp3",".wav",".aac"],js:[".js",".mjs",".cjs"],json:[".json"],jsx:[".jsx"],"local-css":[".module.css"],text:[".txt",".html",".md",".xml",".csv"],ts:[".ts",".mts",".cts"],tsx:[".tsx"]};var Sr={base64:["application/octet-stream","application/base64"],binary:["application/octet-stream","application/binary","application/x-binary","image/vnd.microsoft.icon"],copy:["application/octet-stream","application/x-copy"],css:["text/css"],dataurl:["application/data-url","text/data-url"],default:[],empty:[],file:["application/octet-stream","application/x-file","image/jpeg","image/png","image/gif","image/svg+xml","image/webp","image/bmp","image/tiff","image/vnd.microsoft.icon","video/mp4","video/webm","video/ogg","video/x-msvideo","audio/mpeg","audio/ogg","audio/wav","audio/x-aac","audio/webm"],js:["application/javascript","text/javascript","application/x-javascript","application/ecmascript","text/ecmascript"],json:["application/json","text/json"],jsx:["application/javascript","text/javascript","application/jsx"],"local-css":["text/css","text/x-css"],text:["text/plain","text/html","text/markdown","text/xml","text/csv"],ts:["application/typescript","text/typescript"],tsx:["application/typescript","text/typescript","application/tsx"]};var Vo=z(Sr).map(([e,t])=>[e,new Set(t)]),Ko=z(wr).map(([e,t])=>[e,new Set(t)]),Xo=new Re(new Map(Vo)),Yo=new Re(new Map(Ko)),Jo=e=>{let[t,...r]=e.split(";"),o=t.trim().toLowerCase();return Xo.rget(o)},qo=e=>{let t=e.endsWith(".module.css")?".module.css":St(e).extname;return Yo.rget(t)},Cr=e=>{let{headers:t,url:r}=e,o=t.get("content-type")??"",n=Jo(o)??new Set,s=qo(r)??new Set,i=n.intersection(s);return i.size<=0&&(i=s),i.size<=0&&(i=n),i};var Q=console.log,Qo=e=>{let t=Oe(e);return(...r)=>{t(r)}},Ir=[],Zo=Qo(Ir),en=/^[\/\\]([a-z])\:[\/\\]/i,it=e=>{if(j(e)){if(V(e)!=="file")return;e=new URL(e)}return e?.protocol.startsWith("file:")?P(me(e.pathname)).replace(en,"$1:/"):void 0},Le=e=>{let t=j(e),r=it(e);if(!r){let o=t?V(e):"http";o!=="local"&&o!=="relative"&&Q(`[ensureLocalPath] WARNING! received non-convertible remote path: "${t?e:e.href}"`)}return r??(t?P(e):e.href)},Nr=()=>{let e=Ue();return(r,...o)=>{let n=e,[s,i]=ne();return e=s,n.finally(()=>{i(r(...o))}),s}},Or=e=>(Ge(e)||(e=z(e)),e.map(t=>j(t)?[t,t]:Ge(t)?t:[t.in,t.out]));var tn=e=>{let{defaultLoader:t,acceptLoaders:r=Ft,log:o=!1}=e,n=new Set(r),s=o?o===!0?Q:o:void 0;return async i=>{let{path:a,pluginData:c}=i,p=A(a),d=await fetch(p,xe);if(!d.ok)throw new Error(`[urlLoaderFactory]: ERROR: network fetch response for url "${p.href}" was not ok (${d.status}). response header:
${be(d.headers)}`);let l=Cr(d),_=n.intersection(l),f=[..._].at(0)??t,u=await d.bytes();return s&&s("[urlLoaderFactory]:",{path:a,path_url:p.href,guessed_loaders:l,preferred_loader:f,args:i}),{contents:u,loader:f,pluginData:c}}},kr={enabled:!0,resolveAgain:!0},rn={filters:[/^https?\:\/\//,/^file\:\/\//],namespace:"oazmi-loader-http",acceptNamespaces:te,defaultLoader:"copy",acceptLoaders:void 0,convertFileUriToLocalPath:kr,log:!1},on=(e={})=>{let{acceptLoaders:t,defaultLoader:r,filters:o,namespace:n,acceptNamespaces:s,log:i,convertFileUriToLocalPath:a}={...rn,...e},c=new Set([...s,n]),p={acceptLoaders:t,defaultLoader:r,log:i},d={...kr,...a};return async l=>{let{absWorkingDir:_,outdir:f,outfile:u,entryPoints:k,write:G,loader:U}=l.initialOptions,M=async v=>{let{path:E,pluginData:H,namespace:C,...D}=v,y=C===n?"":C;if(c.has(C))return d.enabled&&V(E)==="file"?d.resolveAgain?l.resolve(it(E),{...D,pluginData:H,namespace:y}):{path:it(E),pluginData:H,namespace:y}:{path:E,pluginData:H,namespace:n}};o.forEach(v=>{l.onResolve({filter:v},M)}),l.onLoad({filter:/.*/,namespace:n},tn(p))}},zt=e=>({name:"oazmi-http-plugin",setup:on(e)});var nn={filters:[/^jsr\:/],acceptNamespaces:te},sn=(e={})=>{let{filters:t,acceptNamespaces:r}={...nn,...e},o=new Set([...r,"oazmi-loader-http"]);return async n=>{let{absWorkingDir:s,outdir:i,outfile:a,entryPoints:c,write:p,loader:d}=n.initialOptions,l=async _=>{if(!o.has(_.namespace))return;let{path:f,pluginData:u={},...k}=_,{importMap:G,runtimePackage:U,resolverConfig:M={},...v}=u,E=await Ce.fromUrl(f),H=B(f).pathname,C=H==="/"?".":he(H),D=E.resolveExport(C,{baseAliasDir:""});if(!D)throw new Error(`failed to resolve the path "${f}" from the deno package: "jsr:${E.getName()}@${E.getVersion()}"`);return n.resolve(D,{...k,pluginData:{...v,runtimePackage:E,resolverConfig:{...M,useNodeModules:!1}}})};t.forEach(_=>{n.onResolve({filter:_},l)})}},Bt=e=>({name:"oazmi-jsr-plugin",setup:sn(e)});var jr={enabled:!0},Dr={enabled:!0,globalImportMap:{}},Ar={enabled:!0},Lr={enabled:!0,resolvePath:tt,isAbsolutePath:_e},an={runtimePackage:jr,importMap:Dr,nodeModules:Ar,relativePath:Lr,namespace:"oazmi-resolver-pipeline",log:!1},cn=e=>{let{runtimePackage:t,importMap:r,nodeModules:o,relativePath:n,namespace:s,log:i}={...an,...e},a={...jr,...t},c={...Dr,...r},p={...Ar,...o},d={...Lr,...n},l=i?i===!0?Q:i:void 0,_="discard-this-namespace",f=/.*/;return async u=>{let k=P(u.initialOptions.absWorkingDir??"./"),G=a.enabled===!1?Ae:async y=>{if(y.pluginData?.resolverConfig?.useRuntimePackage===!1)return;let{path:g,pluginData:I={}}=y,b=I.runtimePackage,x=b&&!g.startsWith("./")&&!g.startsWith("../")?b.resolveImport(g):void 0;return l&&l(`[runtime-package] resolving: ${g}`+(x?`
>> successfully resolved to: ${x}`:"")),x?{path:x,namespace:_,pluginData:{...I}}:void 0},{globalImportMap:U}=c,M=c.enabled===!1?Ae:async y=>{if(y.pluginData?.resolverConfig?.useImportMap===!1)return;let{path:g,pluginData:I={}}=y,b={...U,...I.importMap},x=Rr(g,b);return l&&l(`[import-map]      resolving: ${g}`+(x?`
>> successfully resolved to: ${x}`:"")),x?{path:x,namespace:_,pluginData:{...I}}:void 0},{resolvePath:v,isAbsolutePath:E}=d,H=Ht({absWorkingDir:v(T(k))},u),C=p.enabled===!1?Ae:async y=>{let{path:g,resolveDir:I,importer:b,pluginData:x={}}=y;if(x.resolverConfig?.useNodeModules===!1||x.resolverConfig?.useRelativePath!==!1&&(g.startsWith("./")||g.startsWith("../")||E(g)))return;let O=v(T(I||k)),W=P(g),N=H({importer:b,path:W,resolveDir:O}),{path:h,namespace:w,pluginData:S,...L}=await N.catch(()=>({}));return l&&l(`[node-module]     resolving: ${g}`+(h?`
>> successfully resolved to: ${h}`:"")),h?{...L,path:h,namespace:_,pluginData:{...x}}:void 0},D=d.enabled===!1?Ae:async y=>{if(y.pluginData?.resolverConfig?.useRelativePath===!1)return;let{path:g,importer:I,resolveDir:b,pluginData:x={}}=y,O=v(T(b||k)),W=E(I)?I:ce(O,I),N=E(g)?P(g):v(W,he(g));return l&&l(`[absolute-path]   resolving: ${g}`+(N?`
>> successfully resolved to: ${N}`:"")),{path:N,namespace:_,pluginData:{...x}}};u.onResolve({filter:f,namespace:s},G),u.onResolve({filter:f,namespace:s},M),u.onResolve({filter:f,namespace:s},C),u.onResolve({filter:f,namespace:s},D)}},Gt=e=>({name:"oazmi-plugindata-resolvers",setup:cn(e)}),Ht=(e,t)=>{let{absWorkingDir:r}=e,o=n=>s=>{let i=Symbol(),a="the-void",{resolve:c,reject:p,resolveDir:d,importer:l=""}=n,_=V(l),f=_==="local"||_==="file"?A("./",l).href:void 0,u=f??d;u===""&&Q('[nodeModulesResolverFactory]: WARNING! received an empty resolve directory ("args.resolveDir").',`
	we will fallback to esbuild's current-working-directory for filling in the "resolveDir" value,`,`
	however, you must be using the "nodeModulesResolverFactory" function incorrectly to have encountered this situation.`,`
	remember, the purpose of this function is to scan for a node-module, starting from a directory that YOU provide.`),s.onResolve({filter:/.*/},async k=>{if(k.pluginData?.[i]===!0)return;let{path:G,external:U,namespace:M,sideEffects:v,suffix:E}=await s.resolve(Le(k.path),{kind:"entry-point",resolveDir:Le(u!==""?u:k.resolveDir),pluginData:{[i]:!0}});return c({path:P(G),external:U,namespace:M,sideEffects:v,suffix:E}),{path:"does-not-matter.js",namespace:a}}),s.onLoad({filter:/.*/,namespace:a},()=>({contents:"",loader:"empty"}))};return async n=>{let{path:s,resolveDir:i="",importer:a}=n,c=i===""?r??"":i,[p,d,l]=ne(),_={name:"native-esbuild-resolver-capture",setup:o({resolve:d,reject:l,resolveDir:c,importer:a})};return await t.esbuild.build({entryPoints:[s],absWorkingDir:r,bundle:!1,minify:!1,write:!1,outdir:"./temp/",plugins:[_]}).catch(()=>{l("esbuild's native resolver failed to resolve the path")}),p}};var pn={dir:1,command:e=>`npm install "${e}" --no-save`},Tr=Nr(),Mr=new Map,Z="npm:",ln={specifiers:[Z],sideEffects:"auto",autoInstall:!0,peerDependencies:{},acceptNamespaces:te,nodeModulesDirs:[1],log:!1},un=(e={})=>{let{specifiers:t,sideEffects:r,autoInstall:o,peerDependencies:n,acceptNamespaces:s,nodeModulesDirs:i,log:a}={...ln,...e},c=a?a===!0?Q:a:void 0,p=new Set([...s,"oazmi-loader-http"]),d=j(r)?void 0:r,l=Te(o),_=lt(Or(n).map(([f,u])=>{let k=re(f,Z,"")??f,{scope:G,pkg:U}=B(Z+k),M=(G?"@"+G+"/":"")+U,v=re(u,Z,"")??u,{host:E}=B(Z+v);return[M,Z+E]}));return se(l)&&i.unshift(l.dir),async f=>{let{absWorkingDir:u,outdir:k,outfile:G,entryPoints:U,write:M,loader:v}=f.initialOptions,E=T(ye),H=u?T(P(u)):ye,C=b=>{switch(b){case 0:return E;case 1:return H;default:return Fr(b)}},D=[...new Set(i.map(C))],y=mn(f),g=se(l)?{dir:C(l.dir),command:l.command,log:a}:l;g&&f.onStart(async()=>{let b=g==="dynamic",x=z(_);!ue(x)&&1&&c&&c("[npmPlugin] peer-dependency: the following peer dependencies were specified:",_);for(let[O,W]of x){let{host:N,version:h}=B(W),w=h===void 0?O===N:N.startsWith(O+"@"),S=`${O}@npm:${N}`,L=w||b?N:S;!w&&b&&(c??Q)('[npmPlugin]: WARNING! auto peer dependency package installation under an aliased name is not possible with "autoInstall" set to "dynamic".',`
	this will very likely lead to a broken import. please set "autoInstall" to one of the cli options, such as "auto-cli".`,`
	warning generated for the peer dependency package: "${W}", with alias: "${O}".`),await Tr($r,L,g)}});let I=b=>async x=>{if(!p.has(x.namespace))return;let{path:O,pluginData:W={},resolveDir:N="",namespace:h,...w}=x,S=re(O,b,Z),{scope:L,pkg:ee,pathname:X,version:En}=B(S),at=(L?"@"+L+"/":"")+ee,$e=`${at}${X==="/"?"":X}`,{importMap:Rn,runtimePackage:vn,resolverConfig:Ur,...Wr}=W,Kt=N===""?D:[N,...D],ct=Mr.get(at),Xt;if(ct)await ct;else{let[zr,Br]=ne();Mr.set(at,ct=zr),Xt=Br}let Ie=await y($e,Kt);!Ie&&g&&(await Tr($r,S,g),Ie=await y($e,Kt)),Ie||(c??Q)(`[npmPlugin]: WARNING! no valid "resolveDir" directory was found to contain the npm package named "${$e}"`,`
	we will still continue with the path resolution (in case the global-import-map may alter the situation),`,`
	but it is almost guaranteed not to work if the current-working-directory was already part of the scanned directories.`),Xt?.();let Ne=await f.resolve($e,{...w,resolveDir:Ie,namespace:"oazmi-resolver-pipeline",pluginData:{...Wr,resolverConfig:{useRuntimePackage:!1,useImportMap:!1,useNodeModules:!0}}}),Yt=Ne.path;return c&&c(`[npmPlugin]       resolving: "${O}", with resolveDir: "${Ie}"`+(Yt?`
>> successfully resolved to: ${Yt}`:"")),d!==void 0&&(Ne.sideEffects=d),Ne.namespace="",Object.assign(Ne.pluginData.resolverConfig,{...Ur,useRuntimePackage:!1,useNodeModules:!0}),Ne};t.forEach(b=>{let x=new RegExp(`^${Rt(b)}`);f.onResolve({filter:x},I(b))})}},Vt=e=>({name:"oazmi-npm-plugin",setup:un(e)}),Fr=e=>{let t=j(e)?e:e.href,r=V(t),o=ie(T(r==="relative"?ce(T(ye),t):t));switch(r){case"local":case"relative":case"file":return Le(o);default:throw new Error(`expected a filesystem path, or a "file://" url, but received the incompatible uri scheme "${r}".`)}},mn=e=>{let t=Ht({absWorkingDir:void 0},e),r=async(o,n)=>((await t({path:n,importer:"",resolveDir:o})).path??"")!=="";return async(o,n)=>{let s=n.map(Fr);for(let i of s)if(await r(i,o))return i}},Me=je(),dn=e=>`deno cache --node-modules-dir="auto" --allow-scripts --no-config "npm:${e}"`,fn=e=>`deno cache --node-modules-dir="auto" --no-config "npm:${e}"`,hn=e=>`npm install "${e}" --no-save`,gn=e=>`bun install "${e}" --no-save`,_n=e=>`pnpm install "${e}"`,Te=e=>{if(e){if(se(e))return{...pn,...e};switch(e){case"auto":return Me===m.DENO||Me===m.BUN?"dynamic":Te("npm");case!0:case"auto-cli":switch(Me){case m.DENO:return Te("deno");case m.BUN:return Te("bun");case m.NODE:return Te("npm");default:throw new Error("ERROR! cli-installation of npm-packages is not possible on web-browser runtimes.")}case"dynamic":return"dynamic";case"deno":return{dir:1,command:dn};case"deno-noscript":return{dir:1,command:fn};case"bun":return{dir:1,command:gn};case"npm":return{dir:1,command:hn};case"pnpm":return{dir:1,command:_n};default:return}}},$r=async(e,t)=>{switch(Me){case m.DENO:case m.BUN:case m.NODE:return t==="dynamic"?yn(e):xn(e,t);default:throw new Error("ERROR! npm-package installation is not possible on web-browser runtimes.")}},xn=async(e,t)=>{let{command:r,dir:o,log:n}=t,s=n?n===!0?Q:n:void 0,i=B(e.startsWith(Z)?e:Z+e),a=i.host,c=a.includes("@npm:"),p=r(c?e:a);s&&s(`[npmPlugin]      installing: "${e}", in directory "${o}"
>>    using the cli-command: \`${p}\``),await Ct(Me,p,{cwd:o})},yn=async e=>{let t=B(e.startsWith(Z)?e:Z+e),r=t.href.replace(/^npm\:[\/\\]*/,Z).slice(0,t.pathname==="/"?-1:void 0),o=`export * as myLib from "${me(r)}"`,n=new Blob([o],{type:"text/javascript"});await import(URL.createObjectURL(n))};var bn={initialPluginData:void 0,log:!1,logFor:["npm","resolver"],autoInstall:!0,peerDependencies:{},nodeModulesDirs:[1],globalImportMap:{},getCwd:ye,acceptNamespaces:te},Pn=e=>{let{acceptNamespaces:t,autoInstall:r,getCwd:o,globalImportMap:n,log:s,logFor:i,peerDependencies:a,nodeModulesDirs:c,initialPluginData:p}={...bn,...e},d=ke(o,_e);return[Wt({initialPluginData:p,acceptNamespaces:t}),zt({acceptNamespaces:t,log:i.includes("http")?s:!1}),Bt({acceptNamespaces:t}),Vt({acceptNamespaces:t,autoInstall:r,peerDependencies:a,nodeModulesDirs:c,log:i.includes("npm")?s:!1}),Gt({log:i.includes("resolver")?s:!1,importMap:{globalImportMap:n},relativePath:{resolvePath:d}})]};export{nt as DIRECTORY,Ft as allEsbuildLoaders,Zo as arrayLogger,Ir as arrayLoggerHistory,te as defaultEsbuildNamespaces,Pn as denoPlugins,Wt as entryPlugin,zt as httpPlugin,Bt as jsrPlugin,Q as logLogger,Vt as npmPlugin,Gt as resolverPlugin};
