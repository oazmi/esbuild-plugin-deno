function qt(e,t,r){let o=r===void 0?t:t.bind(r),n=e.length-1;for(;n>=0;){if(o(e[n],n,e))return n;n--}return-1}function Xt(e,t,r){let o=e.findLastIndex(t,r);return o===-1?void 0:e[o]}Array.prototype.findLastIndex||(Array.prototype.findLastIndex=function(e,t){return qt(this,e,t)});Array.prototype.findLast||(Array.prototype.findLast=function(e,t){return Xt(this,e,t)});Uint8Array.prototype.findLastIndex||(Uint8Array.prototype.findLastIndex=function(e,t){return qt(this,e,t)});Uint8Array.prototype.findLast||(Uint8Array.prototype.findLast=function(e,t){return Xt(this,e,t)});var $r={},Jt=Wr(globalThis,$r);function Wr(e,t){return new Proxy(e,{get(r,o,n){return o in t?t[o]:e[o]},set(r,o,n){return o in t&&delete t[o],e[o]=n,!0},deleteProperty(r,o){let n=!1;return o in t&&(delete t[o],n=!0),o in e&&(delete e[o],n=!0),n},ownKeys(r){let o=Reflect.ownKeys(e),n=Reflect.ownKeys(t),s=new Set(n);return[...o.filter(i=>!s.has(i)),...n]},defineProperty(r,o,n){return o in t&&delete t[o],Reflect.defineProperty(e,o,n),!0},getOwnPropertyDescriptor(r,o){return o in t?Reflect.getOwnPropertyDescriptor(t,o):Reflect.getOwnPropertyDescriptor(e,o)},has(r,o){return o in t||o in e}})}var Br=Array;var Qt=JSON;var Zt=Number,Ne=Object,ze=Promise;var er=Symbol;var ne=e=>e.length===0;var De=Br.isArray;var at=Qt.parse,ye=Qt.stringify;var Oe=Zt.isFinite;var se=Zt.parseInt,ct=Ne.assign;var $=Ne.entries;var pt=Ne.fromEntries;var tr=Ne.getPrototypeOf;var lt=Ne.keys;var Y=()=>{let e,t;return[new Promise((o,n)=>{e=o,t=n}),e,t]},ut=ze.all.bind(ze);var Be=ze.resolve.bind(ze);var dt=er.iterator;var rr=er.toStringTag;var be=encodeURI;var ve=decodeURI;var T;(function(e){e[e.LOG=0]="LOG",e[e.ASSERT=0]="ASSERT",e[e.ERROR=1]="ERROR",e[e.PRODUCTION=1]="PRODUCTION",e[e.MINIFY=1]="MINIFY"})(T||(T={}));var q=(e,t,...r)=>(o=>e[t].bind(o,...r));var He=(e,t,...r)=>e[t].bind(e,...r),mt=e=>e.prototype,or=mt(Array),pe=mt(Map),ft=mt(Set);var gt=q(or,"pop"),le=q(or,"push");var _t=q(ft,"add");var ht=q(ft,"delete");var xt=q(ft,"has");var yt=q(pe,"delete"),bt=q(pe,"entries"),vt=q(pe,"forEach"),ue=q(pe,"get"),Pe=q(pe,"has"),Pt=q(pe,"keys"),Ee=q(pe,"set"),Et=q(pe,"values");var Ae=e=>tr(e).constructor;var Ge=e=>{let t=typeof e;return t==="object"||t==="function"};var ie=e=>typeof e=="object",Ke=De;var y=e=>typeof e=="string";var Yr=/[.*+?^${}()|[\]\\]/g,Re=e=>e.replaceAll(Yr,"\\$&"),te=(e,t,r="")=>e.startsWith(t)?r+e.slice(t.length):void 0,Ve=(e,t,r="")=>e.endsWith(t)?(t===""?e:e.slice(0,-t.length))+r:void 0,qr=`\r
`,O;(function(e){e[e.NONE=0]="NONE",e[e.STRING=1]="STRING",e[e.INLINE_COMMENT=2]="INLINE_COMMENT",e[e.MULTILINE_COMMENT=3]="MULTILINE_COMMENT"})(O||(O={}));var Rt=e=>{e=" "+e.replaceAll(qr,`
`)+" ";let t=e.length-1,r=[],o=le(r),n=gt(r),s=O.NONE;for(let i=1;i<t;i++){let a=e[i];switch(a){case"/":{if(s===O.NONE){let c=e[i+1];if(s=c==="/"?O.INLINE_COMMENT:c==="*"?O.MULTILINE_COMMENT:O.NONE,s!==O.NONE){i++;continue}}break}case"*":{if(s===O.MULTILINE_COMMENT&&(s=e[i+1]==="/"?O.NONE:s,s===O.NONE)){i++;continue}break}case`
`:s=s===O.INLINE_COMMENT?O.NONE:s;case"	":case"\v":case" ":{if(s===O.NONE)continue;break}case'"':{s=s===O.NONE?O.STRING:s===O.STRING?O.NONE:s;break}case"}":case"]":{if(s===O.NONE){let c=n();c!==","&&o(c)}break}}(s===O.NONE||s===O.STRING)&&o(a==="\\"?a+e[++i]:a)}return r.join("")};var Xr=$({"node:":"node","npm:":"npm","jsr:":"jsr","blob:":"blob","data:":"data","http://":"http","https://":"https","file://":"file","./":"relative","../":"relative"}),Jr=["blob","data","relative"],Qr=["jsr","npm","node"],Zr=["jsr:","npm:","node:"],J="/",Ye="./",wt="../",eo=/\\/g,to=/^[a-z]\:[\/\\]/i,ro=/^[\/\\]([a-z])\:[\/\\]/i,oo=/^\/+/;var no=/\/?[^\/]+$/,so=/^(?<basename>.+?)(?<ext>\.[^\.]+)?$/,io=/^(?<protocol>jsr:|npm:|node:)(\/*(@(?<scope>[^\/\s]+)\/)?(?<pkg>[^@\/\s]+)(@(?<version>[^\/\r\n\t\f\v]+))?)?(?<pathname>\/.*)?$/,ae=(e,t)=>e.startsWith(t),cr=(e,t)=>e.endsWith(t),kt=e=>ae(e,J)||ae(e,"~")||to.test(e),H=e=>{if(!(!e||e==="")){for(let[t,r]of Xr)if(ae(e,t))return r;return kt(e)?"local":"relative"}},z=e=>{e=ve(y(e)?e:e.href);let{protocol:t,scope:r,pkg:o,version:n,pathname:s}=io.exec(e)?.groups??{};if(t===void 0||o===void 0)throw new Error(T.ERROR?"invalid package url format was provided: "+e:"");let i=r||void 0,a=n||void 0,c=s||J,p=`${i?"@"+i+J:""}${o}${a?"@"+a:""}`,u=be(`${t}/${p}${c}`);return{protocol:t,scope:i,pkg:o,version:a,pathname:c,host:p,href:u}},F=(e,t)=>{if(!y(e))return e;e=C(e);let r=t;if(y(t)&&t!==""){let u=H(t);if(Jr.includes(u))throw new Error(T.ERROR?"the following base scheme (url-protocol) is not supported: "+u:"");r=F(t)}let o=H(e),n=r?r.protocol:void 0,s=Qr.includes(o),i=Zr.includes(n),a=ae(e,"/"),c=o==="local",p=o==="relative";if(s)return new URL(z(e).href);if(r&&i&&(a||p)){let{host:u,protocol:l,pathname:f}=z(r);if(a)return new URL(`${l}/${be(u)}${be(e)}`);if(p){let d=new URL(e,"x:"+f).pathname;return new URL(`${l}/${be(u)}${d}`)}}return r&&(a||p)?new URL(e,r):c?new URL("file://"+be(e)):new URL(e)},ao=e=>e.replace(oo,"");var de=e=>ae(e,Ye)?e:ae(e,J)?"."+e:Ye+e,A=e=>cr(e,J)?e:e+J;var pr=(e,t={})=>{let{keepRelative:r=!0}=ie(t)?t:{},o=e.split(J),n=o.at(-1),s=[".."],i=r&&o[0]===".";o.length>=2&&(n==="."||n==="..")&&o.push("");for(let c of o)c===".."?s.at(-1)!==".."?s.pop():s.push(c):c!=="."&&s.push(c);return s.shift(),i&&s[0]!==".."&&s.unshift("."),s.join(J)},me=(e,t)=>pr(C(e),t),C=e=>e.replaceAll(eo,J);var ar=e=>ao(no.exec(e)?.[0]??""),co=e=>{let{basename:t="",ext:r=""}=so.exec(e)?.groups??{};return[t,r]},fe=e=>{let t=me(e),r=ar(t),o=r.length,n=o>0?t.slice(0,-o):t,s=ar(n.slice(0,-1)),[i,a]=co(r);return{path:t,dirpath:n,dirname:s,filename:r,basename:i,extname:a}},Le=e=>{if(y(e)){if(H(e)!=="file")return;e=new URL(e)}return ae(e.protocol,"file:")?C(ve(e.pathname)).replace(ro,"$1:/"):void 0},re=e=>{let t=y(e);return Le(e)??(t?C(e):e.href)};var lr=(...e)=>{e=e.map(r=>r==="."?Ye:r===".."?wt:r);let t=e.reduce((r,o)=>{let n=r.pop(),s=cr(n,J),i=s?n:n+J;if(!s){let a=ae(o,Ye),c=ae(o,wt);a?o="."+o:c&&(o=wt+o)}return r.push(i,o),r},[J]);return t.shift(),pr(t.join(""))},oe=(...e)=>lr(...e.map(C)),po=(e,t=kt)=>{let r=y(e)?(()=>e):e;return(...o)=>{let n=o.findLastIndex(t);return n>=0?o=o.slice(n):o.unshift(A(r())),lr(...o)}},St=(e,t=kt)=>{y(e)&&(e=C(e));let r=y(e)?(()=>e):(()=>C(e())),o=po(r,t);return(...n)=>o(...n.map(C))};var g;(function(e){e[e.DENO=0]="DENO",e[e.BUN=1]="BUN",e[e.NODE=2]="NODE",e[e.CHROMIUM=3]="CHROMIUM",e[e.EXTENSION=4]="EXTENSION",e[e.WEB=5]="WEB",e[e.WORKER=6]="WORKER"})(g||(g={}));var U=Jt,lo={[g.DENO]:()=>!!U.Deno?.version,[g.BUN]:()=>!!U.Bun?.version,[g.NODE]:()=>!!U.process?.versions,[g.CHROMIUM]:()=>!!U.chrome?.runtime,[g.EXTENSION]:()=>!!U.browser?.runtime,[g.WEB]:()=>!!U.window?.document,[g.WORKER]:()=>!!(ie(U.self)&&Ge(U.WorkerGlobalScope)&&U.self instanceof U.WorkerGlobalScope)},uo=[g.DENO,g.BUN,g.NODE,g.CHROMIUM,g.EXTENSION,g.WEB,g.WORKER],Me=()=>{for(let e of uo)if(lo[e]())return e;throw new Error(T.ERROR?`failed to detect current javascript runtime!
please report this issue to "https://github.com/omar-azmi/kitchensink_ts/issues", along with information on your runtime environment.`:"")},ur=e=>{switch(e){case g.DENO:return U.Deno;case g.BUN:return U.Bun;case g.NODE:return U.process;case g.CHROMIUM:return U.chrome;case g.EXTENSION:return U.browser;case g.WEB:return U.window;case g.WORKER:return U.self;default:throw new Error(T.ERROR?`an invalid runtime enum was provided: "${e}".`:"")}},dr=(e,t=!0)=>{let r=ur(e);if(!r)throw new Error(T.ERROR?`the requested runtime associated with the enum "${e}" is undefined (i.e. you're running on a different runtime from the provided enum).`:"");switch(e){case g.DENO:case g.BUN:case g.NODE:return C(r.cwd());case g.CHROMIUM:case g.EXTENSION:return r.runtime.getURL("");case g.WEB:case g.WORKER:return new URL("./",t?r.location.href:r.location.origin).href}};var mo={args:[]},Ct=async(e,t,r={})=>{let{args:o,cwd:n,signal:s}={...mo,...r},i=ne(o);if(!ur(e))throw new Error(T.ERROR?`the requested runtime associated with the enum "${e}" is undefined (i.e. you're running on a different runtime from the provided enum).`:"");if(!t&&i)return{stdout:"",stderr:""};switch(e){case g.DENO:case g.BUN:case g.NODE:{let{exec:c}=await _o(),p=i?t:`${t} ${o.join(" ")}`,[u,l,f]=Y();return c(p,{cwd:n?re(n):void 0,signal:s},(d,_,E)=>{d&&f(d.message),l({stdout:_,stderr:E})}),u}default:throw new Error(T.ERROR?`your non-system runtime environment enum ("${e}") does not support shell commands`:"")}};var fo;var go=async()=>import("node:child_process"),_o=async()=>fo??=await go();var ho=["size","mtime","atime","birthtime","ctime","dev","mode"],Ds=["isFile","isDirectory","isSymlink",...ho];var It=e=>{let t=[];e.forEach(n=>{t.push(...n)});let r=new Map([...new Set(t)].map(n=>[n,new Set])),o=ue(r);for(let[n,s]of e)s.forEach(i=>o(i).add(n));return r},we=class{constructor(t,r){let o=t??(r?It(r):new Map),n=r??(t?It(t):new Map),s=Ee(o),i=Ee(n),a=yt(o),c=yt(n),p=o.size,u=n.size,l=vt(o),f=vt(n),d=ue(o),_=ue(n),E=Pe(o),K=Pe(n),V=bt(o),j=bt(n),L=Pt(o),I=Pt(n),W=Et(o),B=Et(n),R=(m,...k)=>{let S=d(m)??(s(m,new Set)&&d(m)),M=xt(S),Z=_t(S);for(let X of k)M(X)||(Z(X),_(X)?.add(m)||i(X,new Set([m])))},x=(m,...k)=>{let S=_(m)??(i(m,new Set)&&_(m)),M=xt(S),Z=_t(S);for(let X of k)M(X)||(Z(X),d(X)?.add(m)||s(X,new Set([m])))},h=()=>{o.clear(),n.clear()},v=(m,k=!1)=>{let S=d(m);if(S){for(let M of S)_(M).delete(m);k?S.clear():k=a(m)}return k},b=(m,k=!1)=>{let S=_(m);if(S){for(let M of S)d(M).delete(m);k?S.clear():k=c(m)}return k};ct(this,{fmap:o,rmap:n,size:p,rsize:u,forEach:l,rforEach:f,get:d,rget:_,has:E,rhas:K,entries:V,rentries:j,keys:L,rkeys:I,values:W,rvalues:B,add:R,radd:x,clear:h,delete:v,rdelete:b,remove:(m,...k)=>{let S=d(m);if(S){let M=ht(S);for(let Z of k)M(Z)&&_(Z).delete(m)}},rremove:(m,...k)=>{let S=_(m);if(S){let M=ht(S);for(let Z of k)M(Z)&&d(Z).delete(m)}},set:(m,k)=>(v(m,!0),R(m,...k),this),rset:(m,k)=>(b(m,!0),x(m,...k),this),[dt]:V,[rr]:"InvertibleMap"})}};var qe=class{wmap=new WeakMap;smap=new Map;pick(t){return Ge(t)?this.wmap:this.smap}get(t){return this.pick(t).get(t)}set(t,r){return this.pick(t).set(t,r),this}has(t){return this.pick(t).has(t)}delete(t){return this.pick(t).delete(t)}},xo=Symbol(T.MINIFY||"represents an unset value for a tree");var ei=Symbol(T.MINIFY||"a rejection by a throttled function"),ti=Symbol(T.MINIFY||"a timeout by an awaited promiseTimeout function");var yo=(e,t=!1)=>{let r=t?new qe:new Map,o=He(r,"get"),n=He(r,"set"),s=He(r,"has");return{fn:a=>{let c=s(a),p=c?o(a):e(a);return c||n(a,p),p},memory:r}},Nt=e=>yo(e).fn;var Xe="x|0|[1-9]\\d*",bo=`(?<major>${Xe})\\.(?<minor>${Xe})\\.(?<patch>${Xe})`,vo="(?<prerelease>[^\\+\\s]*)",Po="(?<build>[^\\s]*)",mr=new RegExp(`${bo}(?:\\-${vo})?(?:\\+${Po})?`),Eo=/^\=*v*\s*/i,Ro=/^[xX\\*]$/,wo=/\-|\+/,ko=new RegExp(`^${Xe}$`),So="<=|>=|!=|<|>|=|\\^|\\~",Co=new RegExp(`^(?<operator>${So})?\\s*(?<semver>.*)$`),Dt=(e,t)=>e>t?1:e===t?0:-1,Io=e=>{let t=mr.exec(e);if(!t)return;let{major:r="0",minor:o="0",patch:n="0",prerelease:s="",build:i=""}=t.groups,a=se(r),c=se(o),p=se(n);return Oe(a)&&Oe(c)&&Oe(p)?{major:a,minor:c,patch:p,prerelease:s,build:i}:void 0},Je=e=>e.trim().replace(Eo,""),Qe=e=>Io(Je(e)),No=e=>{let{major:t="x",minor:r="x",patch:o="x",build:n="",prerelease:s=""}=e;return`${t}.${r}.${o}`+(s?"-"+s:"")+(n?"+"+n:"")},fr=(e,t)=>{e=y(e)?Qe(e):e,t=y(t)?Qe(t):t;let{major:r,minor:o,patch:n}=e,{major:s,minor:i,patch:a}=t;return r!==s?Dt(r,s):o!==i?Dt(o,i):Dt(n,a)},Do=e=>e.map(r=>y(r)?Qe(r):r).toSorted(fr),Oo=e=>{let r=e.search(wo),o=r>=0?e[r]:"-",[n="",s=""]=e.split(o,2),i=n.split(".").toReversed(),a=[],c=ne(i);for(let p=0;p<3;p++){let u=i.pop()||"x",l=Ro.test(u)?"x":u;c||=!ko.test(l),a.push(c?"x":l)}return a.join(".")+(s?o+s:"")},Ao=e=>{let t=Co.exec(e),r="x";if(!t)throw new Error(`[semver]: invalid comparator: "${e}"`);let{operator:o="",semver:n=""}=t.groups,s=o||"=",i=mr.exec(Oo(Je(n)));if(!i)throw new Error(`[semver]: error parsing semver: "${n}"`);let{major:a=r,minor:c=r,patch:p=r,prerelease:u="",build:l=""}=i.groups,f=a===r?void 0:se(a),d=c===r?void 0:se(c),_=p===r?void 0:se(p);return{operator:s,major:f,minor:d,patch:_,prerelease:u,build:l}},Ot={tokenExp:"[OR]",parseExp:/\s*\|\|\s*/g,lexer(e){return e.split(this.tokenExp)}},Ze={tokenExp:"[HYPHEN]",parseExp:/\s+\-\s+/g,lexer(e){let t=e.match(Lo);if(!t)return;let r=Je(t[1]),o=Je(t[2]);return[r,o]}},Lo=new RegExp(`^(.+?)${Re(Ze.tokenExp)}(.+?)$`),At={tokenExp:"[AND]",parseExp:/\s+/g,lexer(e){return e.split(this.tokenExp)}},Mo=["=","!=",">=","<=",">","<","~","^"],jo=[">","<","!="],To=e=>{for(let t of Mo)e=e.replaceAll(new RegExp(`${Re(t)}\\s*`,"g"),t);return e},ke=e=>{if(y(e)){let a=Ze.lexer(e);if(a){let[c,p]=a;return[...ke(`>=${c}`),...ke(`<=${p}`)]}e=Ao(e)}let{operator:t="=",major:r,minor:o,patch:n,prerelease:s,build:i}=e;if(r===void 0)return jo.includes(t)?[{operator:"=",major:-1,minor:-1,patch:-1}]:[{operator:">=",major:0,minor:0,patch:0}];if(o===void 0)switch(t){case"!=":return[{operator:"<",major:r,minor:0,patch:0},{operator:">=",major:r+1,minor:0,patch:0}];case"<":return[{operator:"<",major:r,minor:0,patch:0}];case"<=":return[{operator:"<",major:r+1,minor:0,patch:0}];case">":return[{operator:">=",major:r+1,minor:0,patch:0}];case">=":return[{operator:">=",major:r,minor:0,patch:0}];default:return ke({operator:"^",major:r,minor:0,patch:0})}if(n===void 0)switch(t){case"!=":return[{operator:"<",major:r,minor:o,patch:0},{operator:">=",major:r,minor:o+1,patch:0}];case"<":return[{operator:"<",major:r,minor:o,patch:0}];case"<=":return[{operator:"<",major:r,minor:o+1,patch:0}];case">":return[{operator:">=",major:r,minor:o+1,patch:0}];case">=":return[{operator:">=",major:r,minor:o,patch:0}];case"^":if(r>0||o>0)return ke({operator:"^",major:r,minor:o,patch:0});default:return ke({operator:"~",major:r,minor:o,patch:0})}switch(t){case"^":{let a,c;return r>0?(a={operator:">=",major:r,minor:o,patch:n,prerelease:s,build:i},c={operator:"<",major:r+1,minor:0,patch:0}):o>0?(a={operator:">=",major:0,minor:o,patch:n,prerelease:s,build:i},c={operator:"<",major:0,minor:o+1,patch:0}):(a={operator:"=",major:0,minor:0,patch:n,prerelease:s,build:i},c=a),[a,c]}case"~":{let a={operator:">=",major:r,minor:o,patch:n,prerelease:s,build:i},c={operator:"<",major:r,minor:o+1,patch:0};return[a,c]}default:return[{operator:t,major:r,minor:o,patch:n,prerelease:s,build:i}]}},gr=e=>{let t=To(e).replaceAll(Ot.parseExp,Ot.tokenExp).replaceAll(Ze.parseExp,Ze.tokenExp).replaceAll(At.parseExp,At.tokenExp),r=[];for(let o of Ot.lexer(t)){let n=[];r.push(n);let s=At.lexer(o).map(ke).flat(1);n.push(...s)}return r},Fo=[["=","<=",">="],["!=",">",">="],["!=","<","<="]],Uo=(e,t)=>{e=y(e)?Qe(e):e,t=y(t)?gr(t):t;for(let r of t){let o=!0;for(let n of r){let s=n.operator,i=fr(e,n);if(Fo.at(i).includes(s)===!1||n.major<0){o=!1;break}}if(o)return!0}return!1},Lt=(e,t)=>{t=y(t)?gr(t):t;let r=Do(e).toReversed();for(let o of r)if(Uo(o,t))return No(o)};var ce=e=>(H(e)??"relative")!=="relative",je=e=>e.startsWith("./")||e.startsWith("../"),Mt=(e,t=ce)=>{let r=St(e,t);return(o,n)=>{if(!o)return r();if(o.startsWith("/")&&n)return re(F(o,n));if(ce(o))return C(o);let s=de(o);return n?r(n,s):r(s)}},ge={redirect:"follow",cache:"force-cache"},_e=A(C(dr(Me(),!0))),he=Mt(_e,ce),Se=(()=>{});var $o=async(e,t)=>{for(let r of e){let o=await fetch(r,{...ge,...t}).catch(Se);if(o?.ok)return o;await o?.body?.cancel()}},Te=async(e,t)=>{let r=await $o(e,t);if(r){let o=r.url;return r.body?.cancel(),o}};var _r=(e,t)=>{e=me(e);let r=t[e];if(r)return r;let o=lt(t).filter(n=>n.endsWith("/")).toSorted((n,s)=>s.length-n.length);for(let n of o)if(e.startsWith(n)){let s=t[n];if(!s.endsWith("/"))throw new Error(`the value ("${s}") of the matched import-map key ("${n}") for the path alias "${e}" MUST end with a trailing slash ("/") to be specification compliant.`);return e.replace(n,s)}},et=([e,t],[r,o])=>r.length-e.length,Wo={baseAliasDir:"",basePathDir:"",sort:!0,errorCheck:!0},tt=(e,t,r)=>{let{baseAliasDir:o,basePathDir:n,errorCheck:s,sort:i}={...Wo,...r};o=Ve(o,"/")??o,n=Ve(n,"/")??n;let a=te(me(e),o),c=a===""||o!==""&&a?.startsWith("/")?"."+a:a;if(c===void 0)return tt(e,t,{baseAliasDir:"",basePathDir:n,errorCheck:s,sort:i});i&&(t=t.toSorted(et));for(let[p,u]of t){let l=te(c,p);if(l!==void 0){if(s&&p.endsWith("/")&&!u.endsWith("/"))throw new Error(`the value ("${u}") of the matched import-map key ("${p}") for the path alias "${e}" MUST end with a trailing slash ("/") to be specification compliant.`);let f=n===""||ce(u)?u:oe(A(n),u);if(l==="")return f;if(p.endsWith("/"))return oe(f,de(l))}}};var hr=new Map,Fe=class{packagePath;packageInfo;constructor(t,r){this.packageInfo=t,this.packagePath=r}getPath(){return this.packagePath}resolveExport(t,r){if(!r?.workspaceExportsVisited?.has(this.getPath()))return tt(t,this.exportMapSortedEntries,{sort:!1,...r})}resolveImport(t,r){if(!r?.workspaceImportsVisited?.has(this.getPath()))return tt(t,this.importMapSortedEntries,{sort:!1,...r})}static async fromUrl(t){t=F(t,he());let r=t.href,o=hr.get(r);if(o)return o;let[n,s,i]=Y();hr.set(r,n);let a=at(Rt(await(await fetch(t,ge)).text())),c=new this(a,r);return s(c),c}},rt=class extends Fe{workspaceChildren;workspaceParents;constructor(t,r){super(t,r),this.workspaceChildren=[],this.workspaceParents=[]}async addWorkspaceChild(t){let r=Ae(this),o=this.getPath(),n=y(t)||t instanceof URL,s=n?F(t,o):void 0,i=n?await r.fromUrl(s):t;this.workspaceChildren.push(i),i.workspaceParents.push(this)}async addWorkspaceParent(t){let r=Ae(this),o=this.getPath(),n=y(t)||t instanceof URL,s=n?F(t,o):void 0,i=n?await r.fromUrl(s):t;this.workspaceParents.push(i),i.workspaceChildren.push(this)}resolveWorkspaceExport(t,r){let{workspaceExportsVisited:o=new Set,...n}=r??{},s=this.workspaceChildren,i=this.getPath();if(!o.has(i)){o.add(i);for(let a of s){let c=a.resolveExport(t,{workspaceExportsVisited:o,...n})??a.resolveWorkspaceExport(t,{workspaceExportsVisited:o,...n});if(c!==void 0)return y(c)?[c,a]:c}}}resolveWorkspaceImport(t,r){let{workspaceImportsVisited:o=new Set,...n}=r??{},s=this.workspaceParents,i=this.getPath();if(!o.has(i)){o.add(i);for(let a of s){let c=a.resolveImport(t,{workspaceImportsVisited:o,...n})??a.resolveWorkspaceImport(t,{workspaceImportsVisited:o,...n});if(c!==void 0)return y(c)?[c,a]:c}}}};var xr=new Map,xe=class extends rt{importMapSortedEntries;exportMapSortedEntries;getName(){return this.packageInfo.name??"@no-name/package"}getVersion(){return this.packageInfo.version??"0.0.0"}getPath(){let t=this.packagePath;return t||`${jt}/${this.getName()}/${this.getVersion()}/deno.json`}constructor(t,r){super(t,r);let{exports:o={},imports:n={}}=t,s=y(o)?o.endsWith("/")?{"./":o}:{".":o}:o,i={...n};for(let[a,c]of $(i)){let p=A(a);a!==p&&!(p in i)&&(i[p]=A(c))}this.exportMapSortedEntries=$(s).toSorted(et),this.importMapSortedEntries=$(i).toSorted(et)}resolveExport(t,r){let o=this.getPath();if(r?.workspaceExportsVisited?.has(o))return;let n=this.getName(),s=this.getVersion(),{baseAliasDir:i,basePathDir:a=fe(o).dirpath,...c}=r??{},p=i===void 0?[`jsr:${n}@${s}`,`jsr:${n}`,`${n}`]:[i];for(let u of p){let l=te(t,u)?.replace(/^\/+/,"/");l!==void 0&&(t=u+(l==="/"?"":l));let f=super.resolveExport(t,{baseAliasDir:u,basePathDir:a,...c});if(f)return f}}resolveImport(t,r){let o=this.getPath();if(r?.workspaceImportsVisited?.has(o))return;let n=fe(o).dirpath,s=je(t),i=s?"":void 0;return this.resolveExport(t,{...r,baseAliasDir:i})??super.resolveImport(t,{...r,basePathDir:n})}resolveWorkspaceImport(t,r){return this.resolveWorkspaceExport(t,r)??super.resolveWorkspaceImport(t,r)}static async fromUrl(t){let r=F(t,he()),o=r.href,n=o.startsWith("jsr:"),s=o.endsWith("/");if(n){let{host:f}=z(t);t=await Bo(`jsr:${f}`)}else if(s){let f=ot.map(_=>new URL(_,r)),d=await Te(f);if(!d)throw new Error(`Scan Error! failed to find a "./deno.json(c)" or "./jsr.json(c)" package file in your supplied directory: "${r}".`);t=d}let i=await super.fromUrl(t),a=i.getPath(),c=xr.get(a);if(c)return await c,i;let[p,u,l]=Y();return xr.set(a,p),await ut((i.packageInfo.workspace??[]).map(async f=>{let d=A(he(f,a));await i.addWorkspaceChild(d)})),u(),i}},jt="https://jsr.io",ot=["./deno.json","./deno.jsonc","./jsr.json","./jsr.jsonc"],zo=async e=>{let{protocol:t,scope:r,pkg:o,pathname:n,version:s}=z(e);if(t!=="jsr:")throw new Error(`expected path protocol to be "jsr:", found "${t}" instead, for package: "${e}"`);if(!r)throw new Error(`expected jsr package to contain a scope, but found "${r}" instead, for package: "${e}"`);let i=new URL(`@${r}/${o}/meta.json`,jt),a=await(await fetch(i,ge)).json(),c=$(a.versions).filter(([d,{yanked:_}])=>!_).map(([d])=>d),p=Lt(c,s??a.latest);if(!p)throw new Error(`failed to find the desired version "${s}" of the jsr package "${e}", with available versions "${ye(a.versions)}"`);let u=new URL(`@${r}/${o}/${p}/`,jt),l=ot.map(d=>new URL(d,u)),f=await Te(l,{method:"HEAD"});if(f)return new URL(f);throw new Error(`Network Error: couldn't locate "${e}"'s package json file. searched in the following locations:
${ye(l)}`)},Bo=Nt(zo);var G=console.log,Ho=e=>{let t=le(e);return(...r)=>{t(r)}},yr=[],Go=Ho(yr),br=()=>{let e=Be();return(r,...o)=>{let n=e,[s,i]=Y();return e=s,n.finally(()=>{i(r(...o))}),s}},vr=e=>(Ke(e)||(e=$(e)),e.map(t=>y(t)?[t,t]:Ke(t)?t:[t.in,t.out]));var ee=[void 0,"","file"],Tt=["base64","binary","copy","css","dataurl","default","empty","file","js","json","jsx","local-css","text","ts","tsx"],nt=(r=>(r[r.CWD=0]="CWD",r[r.ABS_WORKING_DIR=1]="ABS_WORKING_DIR",r))(nt||{});var Ko={filters:[/.*/],initialPluginData:void 0,forceInitialPluginData:!1,enableInheritPluginData:!0,scanAncestralWorkspaces:!1,acceptNamespaces:ee},Pr="<stdin>",Vo=e=>{let{filters:t,initialPluginData:r,forceInitialPluginData:o,enableInheritPluginData:n,scanAncestralWorkspaces:s,acceptNamespaces:i}={...Ko,...e},a=new Set([...i,"oazmi-loader-http"]),c=new Map,p=ue(c),u=Ee(c),l=Pe(c),f=Symbol("[oazmi-entry]: already captured by initial-data-injector"),d=Symbol("[oazmi-entry]: already captured by inherit-data-injector"),_=Symbol("[oazmi-entry]: already captured by absolute-path-resolver");return async E=>{let{runtimePackage:K,...V}=r??{},j=V,L=r!==void 0;E.onStart(async()=>{j.runtimePackage=await Yo(E,K,s);let R=E.initialOptions.stdin;if(R){let{sourcefile:x=Pr,resolveDir:h=""}=R,v=x===Pr?x:h?oe(h,x):C(x);u(v,j)}});let I=async R=>{let{path:x,pluginData:h,...v}=R,{kind:b,namespace:P}=v;if(b!=="entry-point"||(h??{})[f]||!a.has(P)||h!==void 0&&!o)return;let w=o==="merge"?{...j,...h,[f]:!0}:{...j,[f]:!0},N=await E.resolve(x,{...v,pluginData:w});return N.pluginData??=w,N},W=async R=>{let{path:x,pluginData:h,...v}=R,{importer:b="",namespace:P}=v;if((h??{})[d]||!a.has(P))return;if(h==null&&b!==""){let m=p(C(b));return m?W({...v,path:x,pluginData:m}):void 0}let w={...h,[d]:!0},N=await E.resolve(x,{...v,pluginData:w}),D={...N.pluginData??w,[d]:!1};if(D.resolverConfig?.useInheritPluginData!==!1){let m=C(N.path);l(m)||u(C(N.path),D)}return N.pluginData=D,N},B=async R=>{if((R.pluginData??{})[_]||!a.has(R.namespace))return;let{path:x,namespace:h,...v}=R,b=await E.resolve(x,{...v,namespace:"oazmi-resolver-pipeline"}),{path:P,pluginData:w={},namespace:N}=b,D={...w,[_]:!0},m=await E.resolve(P,{...v,namespace:h,pluginData:D});return m.pluginData={...m.pluginData??D,[_]:!1},m};for(let R of t)L&&E.onResolve({filter:R},I),n&&E.onResolve({filter:R},W),E.onResolve({filter:R},B)}},$t=e=>({name:"oazmi-entry",setup:Vo(e)}),Yo=async(e,t,r=!0)=>{let o,n;if(t)return t instanceof Fe?o=t:(n=y(t)&&H(t)==="relative"?(await e.resolve(t,{kind:"entry-point",namespace:"oazmi-resolver-pipeline",pluginData:{resolverConfig:{useNodeModules:!1}}})).path:t,o=await xe.fromUrl(n).catch(i=>{G(`[resolveRuntimePackage]    : ${i?.message??i}`)})),r&&(o??n)&&await Er(o?.getPath()??n),o},Er=async e=>{let t=F("./",e),r=F("../",t);if(r.href===t.href)return;let o=ot.map(s=>new URL(s,t)),n=await Te(o);if(n){let s=await xe.fromUrl(n).catch(i=>{G(`[resolveRuntimePackage]    : workspace file at "${n}" was found, but we failed to load it as a deno package. reason:  ${i?.message??i}`)})}return Er(r)};var Rr={base64:[],binary:[".bin",".dat"],copy:[],css:[".css"],dataurl:[],default:[],empty:[],file:[".jpg",".jpeg",".png",".gif",".svg",".webp",".bmp",".tiff",".ico",".mp4",".webm",".ogg",".avi",".mp3",".wav",".aac"],js:[".js",".mjs",".cjs"],json:[".json"],jsx:[".jsx"],"local-css":[".module.css"],text:[".txt",".html",".md",".xml",".csv"],ts:[".ts",".mts",".cts"],tsx:[".tsx"]};var wr={base64:["application/octet-stream","application/base64"],binary:["application/octet-stream","application/binary","application/x-binary","image/vnd.microsoft.icon"],copy:["application/octet-stream","application/x-copy"],css:["text/css"],dataurl:["application/data-url","text/data-url"],default:[],empty:[],file:["application/octet-stream","application/x-file","image/jpeg","image/png","image/gif","image/svg+xml","image/webp","image/bmp","image/tiff","image/vnd.microsoft.icon","video/mp4","video/webm","video/ogg","video/x-msvideo","audio/mpeg","audio/ogg","audio/wav","audio/x-aac","audio/webm"],js:["application/javascript","text/javascript","application/x-javascript","application/ecmascript","text/ecmascript"],json:["application/json","text/json"],jsx:["application/javascript","text/javascript","application/jsx"],"local-css":["text/css","text/x-css"],text:["text/plain","text/html","text/markdown","text/xml","text/csv"],ts:["application/typescript","text/typescript"],tsx:["application/typescript","text/typescript","application/tsx"]};var qo=$(wr).map(([e,t])=>[e,new Set(t)]),Xo=$(Rr).map(([e,t])=>[e,new Set(t)]),Jo=new we(new Map(qo)),Qo=new we(new Map(Xo)),Zo=e=>{let[t,...r]=e.split(";"),o=t.trim().toLowerCase();return Jo.rget(o)},en=e=>{let t=e.endsWith(".module.css")?".module.css":fe(e).extname;return Qo.rget(t)},kr=e=>{let{headers:t,url:r}=e,o=t.get("content-type")??"",n=Zo(o)??new Set,s=en(r)??new Set,i=n.intersection(s);return i.size<=0&&(i=s),i.size<=0&&(i=n),i};var tn=e=>{let{defaultLoader:t,acceptLoaders:r=Tt,log:o=!1}=e,n=new Set(r),s=o?o===!0?G:o:void 0;return async i=>{let{path:a,pluginData:c}=i,p=F(a),u=await fetch(p,ge);if(!u.ok)throw new Error(`[urlLoaderFactory]: ERROR: network fetch response for url "${p.href}" was not ok (${u.status}). response header:
${ye(u.headers)}`);let l=kr(u),f=n.intersection(l),d=[...f].at(0)??t,_=await u.bytes();return s&&s("[urlLoaderFactory]:",{path:a,path_url:p.href,guessed_loaders:l,preferred_loader:d,args:i}),{contents:_,loader:d,pluginData:c}}},Sr={enabled:!0,resolveAgain:!0},rn={filters:[/^https?\:\/\//,/^file\:\/\//],namespace:"oazmi-loader-http",acceptNamespaces:ee,defaultLoader:"copy",acceptLoaders:void 0,convertFileUriToLocalPath:Sr,log:!1},on=(e={})=>{let{acceptLoaders:t,defaultLoader:r,filters:o,namespace:n,acceptNamespaces:s,log:i,convertFileUriToLocalPath:a}={...rn,...e},c=new Set([...s,n]),p={acceptLoaders:t,defaultLoader:r,log:i},u={...Sr,...a};return async l=>{let{absWorkingDir:f,outdir:d,outfile:_,entryPoints:E,write:K,loader:V}=l.initialOptions,j=async L=>{let{path:I,pluginData:W,namespace:B,...R}=L,x=B===n?"":B;if(c.has(B))return u.enabled&&H(I)==="file"?u.resolveAgain?l.resolve(Le(I),{...R,pluginData:W,namespace:x}):{path:Le(I),pluginData:W,namespace:x}:{path:I,pluginData:W,namespace:n}};o.forEach(L=>{l.onResolve({filter:L},j)}),l.onLoad({filter:/.*/,namespace:n},tn(p))}},Wt=e=>({name:"oazmi-http-plugin",setup:on(e)});var nn={filters:[/^jsr\:/],acceptNamespaces:ee},sn=(e={})=>{let{filters:t,acceptNamespaces:r}={...nn,...e},o=new Set([...r,"oazmi-loader-http"]);return async n=>{let{absWorkingDir:s,outdir:i,outfile:a,entryPoints:c,write:p,loader:u}=n.initialOptions,l=async f=>{if(!o.has(f.namespace))return;let{path:d,pluginData:_={},...E}=f,{importMap:K,runtimePackage:V,resolverConfig:j={},...L}=_,I=await xe.fromUrl(d),W=z(d).pathname,B=W==="/"?".":de(W),R={baseAliasDir:""},x=I.resolveExport(B,R);if(!x)throw new Error(`failed to resolve the path "${d}" from the deno package: "jsr:${I.getName()}@${I.getVersion()}"`);return n.resolve(x,{...E,pluginData:{...L,runtimePackage:I,resolverConfig:{...j,useNodeModules:!1}}})};t.forEach(f=>{n.onResolve({filter:f},l)})}},zt=e=>({name:"oazmi-jsr-plugin",setup:sn(e)});var Cr={enabled:!0},Ir={enabled:!0,globalImportMap:{}},Nr={enabled:!0},Dr={enabled:!0,resolvePath:he,isAbsolutePath:ce},an={runtimePackage:Cr,importMap:Ir,nodeModules:Nr,relativePath:Dr,namespace:"oazmi-resolver-pipeline",log:!1},cn=e=>{let{runtimePackage:t,importMap:r,nodeModules:o,relativePath:n,namespace:s,log:i}={...an,...e},a={...Cr,...t},c={...Ir,...r},p={...Nr,...o},u={...Dr,...n},l=i?i===!0?G:i:void 0,f="discard-this-namespace",d=/.*/;return async _=>{let E=C(_.initialOptions.absWorkingDir??"./"),K=a.enabled===!1?Se:async x=>{if(x.pluginData?.resolverConfig?.useRuntimePackage===!1)return;let{path:h,pluginData:v={}}=x,b=v.runtimePackage,P=b&&!je(h)?b.resolveImport(h)??b.resolveWorkspaceImport(h):void 0,[w,N]=De(P)?P:[P,b];return l&&l(`[runtime-package] resolving: ${h}`+(w?`
>> successfully resolved to: ${w}`:"")),w?{path:w,namespace:f,pluginData:{...v,runtimePackage:N}}:void 0},{globalImportMap:V}=c,j=c.enabled===!1?Se:async x=>{if(x.pluginData?.resolverConfig?.useImportMap===!1)return;let{path:h,pluginData:v={}}=x,b={...V,...v.importMap},P=_r(h,b);return l&&l(`[import-map]      resolving: ${h}`+(P?`
>> successfully resolved to: ${P}`:"")),P?{path:P,namespace:f,pluginData:{...v}}:void 0},{resolvePath:L,isAbsolutePath:I}=u,W=Ht({absWorkingDir:L(A(E))},_),B=p.enabled===!1?Se:async x=>{let{path:h,resolveDir:v,importer:b,pluginData:P={}}=x;if(P.resolverConfig?.useNodeModules===!1||P.resolverConfig?.useRelativePath!==!1&&(je(h)||I(h)))return;let w=L(A(v||E)),N=C(h),D=W({importer:b,path:N,resolveDir:w}),{path:m,namespace:k,pluginData:S,...M}=await D.catch(()=>({}));return l&&l(`[node-module]     resolving: ${h}`+(m?`
>> successfully resolved to: ${m}`:"")),m?{...M,path:m,namespace:f,pluginData:{...P}}:void 0},R=u.enabled===!1?Se:async x=>{if(x.pluginData?.resolverConfig?.useRelativePath===!1)return;let{path:h,importer:v,resolveDir:b,pluginData:P={}}=x,w=L(A(b||E)),N=I(v)?v:oe(w,v),D=L(h,N||void 0);return l&&l(`[absolute-path]   resolving: ${h}`+(D?`
>> successfully resolved to: ${D}`:"")),{path:D,namespace:f,pluginData:{...P}}};_.onResolve({filter:d,namespace:s},K),_.onResolve({filter:d,namespace:s},j),_.onResolve({filter:d,namespace:s},B),_.onResolve({filter:d,namespace:s},R)}},Bt=e=>({name:"oazmi-plugindata-resolvers",setup:cn(e)}),Ht=(e,t)=>{let{absWorkingDir:r}=e,o=n=>s=>{let i=Symbol(),a="the-void",{resolve:c,reject:p,resolveDir:u,importer:l=""}=n,f=H(l),d=f==="local"||f==="file"?F("./",l).href:void 0,_=d??u;_===""&&G('[nodeModulesResolverFactory]: WARNING! received an empty resolve directory ("args.resolveDir").',`
	we will fallback to esbuild's current-working-directory for filling in the "resolveDir" value,`,`
	however, you must be using the "nodeModulesResolverFactory" function incorrectly to have encountered this situation.`,`
	remember, the purpose of this function is to scan for a node-module, starting from a directory that YOU provide.`),s.onResolve({filter:/.*/},async E=>{if(E.pluginData?.[i]===!0)return;let{path:K,external:V,namespace:j,sideEffects:L,suffix:I}=await s.resolve(re(E.path),{kind:"entry-point",resolveDir:re(_!==""?_:E.resolveDir),pluginData:{[i]:!0}});return c({path:C(K),external:V,namespace:j,sideEffects:L,suffix:I}),{path:"does-not-matter.js",namespace:a}}),s.onLoad({filter:/.*/,namespace:a},()=>({contents:"",loader:"empty"}))};return async n=>{let{path:s,resolveDir:i="",importer:a}=n,c=i===""?r??"":i,[p,u,l]=Y(),f={name:"native-esbuild-resolver-capture",setup:o({resolve:u,reject:l,resolveDir:c,importer:a})};return await t.esbuild.build({entryPoints:[s],absWorkingDir:r,bundle:!1,minify:!1,write:!1,outdir:"./temp/",plugins:[f]}).catch(()=>{l("esbuild's native resolver failed to resolve the path")}),p}};var pn={dir:1,command:e=>`npm install "${e}" --no-save`},Or=br(),Ar=new Map,Q="npm:",ln={specifiers:[Q],sideEffects:"auto",autoInstall:!0,peerDependencies:{},acceptNamespaces:ee,nodeModulesDirs:[1],log:!1},un=(e={})=>{let{specifiers:t,sideEffects:r,autoInstall:o,peerDependencies:n,acceptNamespaces:s,nodeModulesDirs:i,log:a}={...ln,...e},c=a?a===!0?G:a:void 0,p=new Set([...s,"oazmi-loader-http"]),u=y(r)?void 0:r,l=Ue(o),f=pt(vr(n).map(([d,_])=>{let E=te(d,Q,"")??d,{scope:K,pkg:V}=z(Q+E),j=(K?"@"+K+"/":"")+V,L=te(_,Q,"")??_,{host:I}=z(Q+L);return[j,Q+I]}));return ie(l)&&i.unshift(l.dir),(async d=>{let{absWorkingDir:_,outdir:E,outfile:K,entryPoints:V,write:j,loader:L}=d.initialOptions,I=A(_e),W=_?A(C(_)):_e,B=b=>{switch(b){case 0:return I;case 1:return W;default:return Mr(b)}},R=[...new Set(i.map(B))],x=dn(d),h=ie(l)?{dir:B(l.dir),command:l.command,log:a}:l;h&&d.onStart(async()=>{let b=h==="dynamic",P=$(f);!ne(P)&&1&&c&&c("[npmPlugin] peer-dependency: the following peer dependencies were specified:",f);for(let[w,N]of P){let{host:D,version:m}=z(N),k=m===void 0?w===D:D.startsWith(w+"@"),S=`${w}@npm:${D}`,M=k||b?D:S;!k&&b&&(c??G)('[npmPlugin]: WARNING! auto peer dependency package installation under an aliased name is not possible with "autoInstall" set to "dynamic".',`
	this will very likely lead to a broken import. please set "autoInstall" to one of the cli options, such as "auto-cli".`,`
	warning generated for the peer dependency package: "${N}", with alias: "${w}".`),await Or(Lr,M,h)}});let v=b=>(async P=>{if(!p.has(P.namespace))return;let{path:w,pluginData:N={},resolveDir:D="",namespace:m,...k}=P,S=te(w,b,Q),{scope:M,pkg:Z,pathname:X,version:Pn}=z(S),st=(M?"@"+M+"/":"")+Z,We=`${st}${X==="/"?"":X}`,{importMap:En,runtimePackage:Rn,resolverConfig:jr,...Tr}=N,Kt=D===""?R:[D,...R],it=Ar.get(st),Vt;if(it)await it;else{let[Fr,Ur]=Y();Ar.set(st,it=Fr),Vt=Ur}let Ce=await x(We,Kt);!Ce&&h&&(await Or(Lr,S,h),Ce=await x(We,Kt)),Ce||(c??G)(`[npmPlugin]: WARNING! no valid "resolveDir" directory was found to contain the npm package named "${We}"`,`
	we will still continue with the path resolution (in case the global-import-map may alter the situation),`,`
	but it is almost guaranteed not to work if the current-working-directory was already part of the scanned directories.`),Vt?.();let Ie=await d.resolve(We,{...k,resolveDir:Ce,namespace:"oazmi-resolver-pipeline",pluginData:{...Tr,resolverConfig:{useRuntimePackage:!1,useImportMap:!1,useNodeModules:!0}}}),Yt=Ie.path;return c&&c(`[npmPlugin]       resolving: "${w}", with resolveDir: "${Ce}"`+(Yt?`
>> successfully resolved to: ${Yt}`:"")),u!==void 0&&(Ie.sideEffects=u),Ie.namespace="",Object.assign(Ie.pluginData.resolverConfig,{...jr,useRuntimePackage:!1,useNodeModules:!0}),Ie});t.forEach(b=>{let P=new RegExp(`^${Re(b)}`);d.onResolve({filter:P},v(b))})})},Gt=e=>({name:"oazmi-npm-plugin",setup:un(e)}),Mr=e=>{let t=y(e)?e:e.href,r=H(t),o=me(A(r==="relative"?oe(A(_e),t):t));switch(r){case"local":case"relative":case"file":return re(o);default:throw new Error(`expected a filesystem path, or a "file://" url, but received the incompatible uri scheme "${r}".`)}},dn=e=>{let t=Ht({absWorkingDir:void 0},e),r=async(o,n)=>((await t({path:n,importer:"",resolveDir:o})).path??"")!=="";return async(o,n)=>{let s=n.map(Mr);for(let i of s)if(await r(i,o))return i}},$e=Me(),mn=e=>`deno cache --node-modules-dir="auto" --allow-scripts --no-config "npm:${e}"`,fn=e=>`deno cache --node-modules-dir="auto" --no-config "npm:${e}"`,gn=e=>`npm install "${e}" --no-save`,_n=e=>`bun install "${e}" --no-save`,hn=e=>`pnpm install "${e}"`,Ue=e=>{if(e){if(ie(e))return{...pn,...e};switch(e){case"auto":return $e===g.DENO||$e===g.BUN?"dynamic":Ue("npm");case!0:case"auto-cli":switch($e){case g.DENO:return Ue("deno");case g.BUN:return Ue("bun");case g.NODE:return Ue("npm");default:throw new Error("ERROR! cli-installation of npm-packages is not possible on web-browser runtimes.")}case"dynamic":return"dynamic";case"deno":return{dir:1,command:mn};case"deno-noscript":return{dir:1,command:fn};case"bun":return{dir:1,command:_n};case"npm":return{dir:1,command:gn};case"pnpm":return{dir:1,command:hn};default:return}}},Lr=async(e,t)=>{switch($e){case g.DENO:case g.BUN:case g.NODE:return t==="dynamic"?yn(e):xn(e,t);default:throw new Error("ERROR! npm-package installation is not possible on web-browser runtimes.")}},xn=async(e,t)=>{let{command:r,dir:o,log:n}=t,s=n?n===!0?G:n:void 0,i=z(e.startsWith(Q)?e:Q+e),a=i.host,c=a.includes("@npm:"),p=r(c?e:a);s&&s(`[npmPlugin]      installing: "${e}", in directory "${o}"
>>    using the cli-command: \`${p}\``),await Ct($e,p,{cwd:o})},yn=async e=>{let t=z(e.startsWith(Q)?e:Q+e),r=t.href.replace(/^npm\:[\/\\]*/,Q).slice(0,t.pathname==="/"?-1:void 0),o=`export * as myLib from "${ve(r)}"`,n=new Blob([o],{type:"text/javascript"});await import(URL.createObjectURL(n))};var bn={initialPluginData:void 0,scanAncestralWorkspaces:!1,log:!1,logFor:["npm","resolver"],autoInstall:!0,peerDependencies:{},nodeModulesDirs:[1],globalImportMap:{},getCwd:_e,acceptNamespaces:ee},vn=e=>{let{acceptNamespaces:t,autoInstall:r,getCwd:o,globalImportMap:n,log:s,logFor:i,peerDependencies:a,nodeModulesDirs:c,initialPluginData:p,scanAncestralWorkspaces:u}={...bn,...e},l=Mt(o,ce);return[$t({initialPluginData:p,scanAncestralWorkspaces:u,acceptNamespaces:t}),Wt({acceptNamespaces:t,log:i.includes("http")?s:!1}),zt({acceptNamespaces:t}),Gt({acceptNamespaces:t,autoInstall:r,peerDependencies:a,nodeModulesDirs:c,log:i.includes("npm")?s:!1}),Bt({log:i.includes("resolver")?s:!1,importMap:{globalImportMap:n},relativePath:{resolvePath:l}})]};export{nt as DIRECTORY,Tt as allEsbuildLoaders,Go as arrayLogger,yr as arrayLoggerHistory,ee as defaultEsbuildNamespaces,vn as denoPlugins,$t as entryPlugin,Wt as httpPlugin,zt as jsrPlugin,G as logLogger,Gt as npmPlugin,Bt as resolverPlugin};
